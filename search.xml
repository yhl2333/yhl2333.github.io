<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL源码解析</title>
      <link href="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ol><li>unordered_set无论是利用上述方法，还是for循环逐个初始化的方式都可以删除重复的元素。</li><li>unordered_set.find()找不到元素会返回.end()迭代器</li><li>unordered_map 模板类中，insert() 方法可以将 pair&lt; , &gt; 类型的键值对元素添加到 unordered_map 容器中。pair&lt; , &gt;类型用{ }表示，与vector一样是大括号。</li><li>unordered_map中不可以重复元素的个数，但可以利用value++来统计重复元素的数量。</li><li>deque实现，512个连续空间构成一个buffer,离散的buffer的指针连续放置构成整个deque</li><li>for(auto ks:vec);for(auto &amp;ks:vec);</li><li>为什么vector（GP）自己不定义sort,而是用标准库中的::sort()?list（OOP）为什么用自己类中的void sort();</li><li>向unorderd_set&lt; int &gt; set1中加入1000000个随机数，set1.size()为MAX_INT。</li><li>unordered_multiset中篮子数必大于其中的元素数，且其中许多篮子为空，许多哈希碰撞的元素构成篮子中的链。</li><li>template类模板，函数模板，模板的特化、偏特化(P10)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>STL链表List，实际上实现是环状链表，这时list.end()就是用一个空节点表示。迭代器的重构P14</li><li>iteraror的traits，萃取机，是个中间层，过滤指针与迭代器，因为只有迭代器能调用STL内部的算法P15</li><li>allocator分配器，实现两个函数，底层分别基于malloc与free。在2.9版本的优化为链表每个节点对应开一大块空间，以节省每次malloc产生的cookie。P11</li><li>cout操作符可以直接输出指针的值，但是对迭代器进行在操作的时候会报错。通过看报错信息和头文件知道，迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</li><li>GNU2.9 iterator_trait的偏特化使得可以接受vector&lt; int &gt;::iterator的int*指针。后续版本中vector的迭代器更改为大类迭代器，因此cout&lt;&lt; vector&lt; int &gt;::iterator输出不了。   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> T;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"><span class="comment">//GNU2.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer,vector&gt; iterator；<span class="comment">//GNU4.9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>deque自身是如何扩容的，扩容后把自己放在原来的中段，deque是如何利用buffer伪装成连续的，deque的迭代器怎样构成的，deque怎样设定buffer的大小</li><li>stack与queue默认以deque为底层，但它们俩由于特殊的进出形式，本身是没有设定迭代器的。stack与queue也可以用链表list作为底层，但以vector,map,set为底层则在部分功能上会出现问题。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">queue&lt;string,list&lt;string&gt;&gt; c1;</span><br><span class="line"></span><br><span class="line">queue&lt;string,vector&lt;string&gt;&gt; c2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用queue各种接口，c1能全部编译通过，c2部分功能不能</p><ol><li>unordered_map、unordered_set、unordered_multimap、unordered_multiset它们的底层是红黑树，unordered_map和unordered_set的插入元素调用的是红黑树的insert_unique(),unordered_multimap和unordered_multiset调用的是insert_equal()。红黑树.begin()返回的迭代器是指向最左下节点的迭代器，红黑树.end()返回的是指向最右下节点的迭代器。</li><li>只有map可以用map[ key ]=value来创建元素,这是map所独有的，multimap用multimap.insert(pair&lt; , &gt;())</li><li>hashtable 底层是vector挂链表，即vector&lt; node*&gt;（如果这个链表很长，就是循序搜索），当插入元素个数大于bucket个数时，进行rehashing篮子数按质数扩大将近一倍，每个元素重新计算hash值并重新插入到hashtable中。</li><li>所有的迭代器分为五类：input_iterator_tag;farward_iterator_tag;bidirectional_iterator_tag;random_access_iterator_tag;<br>output_iterator_tag;</li><li>几乎所有的算法函数格式都一样，在算法函数中传入一个头迭代器，尾迭代器，判断条件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷提总结</title>
      <link href="/leetcode/"/>
      <url>/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="循环停止"><a href="#循环停止" class="headerlink" title="循环停止"></a>循环停止</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>&emsp;&emsp;字符串的终止符是’\0’，可以用’\0’作为跳出循环的判断条件。’\0’在此时被视为0。当指针移动到字符串末尾遇到字符串结束符’\0’，*p就为’\0’循环就会结束</p><p>&emsp;&emsp;例子一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (*p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *(p++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">StrStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> *target)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(!*target)</span> <span class="keyword">return</span> str</span>;</span><br><span class="line">    <span class="type">char</span> *p1 = (<span class="type">char</span>*)str;</span><br><span class="line">    <span class="keyword">while</span> (*p1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *p1Begin = p1, </span><br><span class="line">        <span class="type">char</span> *p2 = (<span class="type">char</span>*)target;</span><br><span class="line">        <span class="keyword">while</span>(*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2)</span><br><span class="line">        &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!*p2)</span><br><span class="line">            <span class="keyword">return</span> p1Begin;</span><br><span class="line">        p1 = p1Begin +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="（链表）指针"><a href="#（链表）指针" class="headerlink" title="（链表）指针"></a>（链表）指针</h2><p>&emsp;&emsp;数据结构中，构造单链表都是定义最后的指针指向NULL，这样指针遇到NULL就不再移动。<br>例子：leetcode第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode*head = result;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n1=l1?l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n2=l2?l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            ListNode* new_point = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> sum=n1+n2+carry;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            new_point-&gt;val=sum%<span class="number">10</span>;</span><br><span class="line">            result-&gt;next=new_point;</span><br><span class="line">            result=result-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* new_point =<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            new_point-&gt;val=<span class="number">1</span>;</span><br><span class="line">            result-&gt;next = new_point; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vector容器（27题）"><a href="#vector容器（27题）" class="headerlink" title="vector容器（27题）"></a>vector容器（27题）</h2><p>&emsp;&emsp;vector容器，底层是定义在heap（堆）中的动态数组<br>&emsp;&emsp;定义了vector&lt; int &gt; nums;如果这个动态数组为空，那么nums[0],nums.size()都会输出很奇怪的数字，而不是所想象的空、0。vector有专门的判别工具，nums.empty()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;nothing&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;vector&lt; string &gt; nums;这个动态容器中,可以对nums[n]进行判断，因为每个nums[n]都是string类型，String类有一个empty()函数,就可以对字符串判空了因此可以调用nums[n].empty()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!v[n].<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于vector<int>，使用vector中的end()函数，判断是否到达最后一个元素，注意nums.end()指向的是最后一个元素的下一个位置，nums.begin()则就是nums的初始位置，它们返回的是迭代器！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">   <span class="comment">//size访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式，迭代器</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Point&gt;::iterator iter = nums.<span class="built_in">begin</span>(); iter != nums.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式，auto关键字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = nums.<span class="built_in">begin</span>(); iter != nums.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种遍历方式，auto关键字的另一种方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : m_testPoint)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;nums.back()返回的是最后一个元素。nums.front()返回的是vector第一个元素。vector.clear()清空容器。</p><h1 id="二分法（704题）"><a href="#二分法（704题）" class="headerlink" title="二分法（704题）"></a>二分法（704题）</h1><h2 id="二分法注意"><a href="#二分法注意" class="headerlink" title="二分法注意"></a>二分法注意</h2><p>&emsp;&emsp;注意是用闭开区间还是闭区间（选择任意）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//左闭右闭  还是左闭右开</span></span><br><span class="line">      <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;<span class="comment">//右开这里去掉减一</span></span><br><span class="line">      <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> middle =<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(left&lt;=right)<span class="comment">//右开这里不取等于</span></span><br><span class="line">      &#123;</span><br><span class="line">        middle=(left+right)/<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">          left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">          right = middle<span class="number">-1</span>;<span class="comment">//因为右边是闭区间，所以减一；右开这里去掉-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><hr><h1 id="如何实现二维数组（leetcode-59）"><a href="#如何实现二维数组（leetcode-59）" class="headerlink" title="如何实现二维数组（leetcode 59）"></a>如何实现二维数组（leetcode 59）</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ol><li>vector&lt; vector&lt; int &gt;&gt; vec(行数, vector&lt; int &gt;(列数)); </li><li>vector&lt; vector&lt; int &gt;&gt; vec(行数, vector&lt; int &gt;(列数, 初始值));</li><li>vector&lt; vector&lt; int &gt;&gt; vec; vec.resize(行数); vec[i].resize(列数); vec[i] = {值};<h2 id="stack定义法"><a href="#stack定义法" class="headerlink" title="stack定义法"></a>stack定义法</h2></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> array[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setarray</span><span class="params">(array[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//M可以省略，N必须存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="heap定义法"><a href="#heap定义法" class="headerlink" title="heap定义法"></a>heap定义法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>** array = <span class="keyword">new</span> <span class="type">int</span>*[M];<span class="comment">//或(int**)malloc(M*sizeof(int*));双指针可以保证arry[i]是int*类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line">    array[i]=<span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>** arr,<span class="type">int</span> M,<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//访问矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    <span class="keyword">delete</span>[] array[i];</span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="删除一个链表节点（LCR-136）"><a href="#删除一个链表节点（LCR-136）" class="headerlink" title="删除一个链表节点（LCR 136）"></a>删除一个链表节点（LCR 136）</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>&emsp;&emsp;在题目给出双指针的情况下，可以考虑这种方法。并且需要单独考虑删除头节点、尾节点、中间节点。</p><h2 id="添加虚拟节点"><a href="#添加虚拟节点" class="headerlink" title="添加虚拟节点"></a>添加虚拟节点</h2><p>&emsp;&emsp;再创一个虚拟节点，将头节点作为虚拟节点的下一个节点，这样仅需要考虑删除中间节点与最后一个节点的情况了。（注意给节点命名是不要用典型的名字）圣经式方法。</p><h1 id="递归实现反转链表（leetcode-206）"><a href="#递归实现反转链表（leetcode-206）" class="headerlink" title="递归实现反转链表（leetcode 206）"></a>递归实现反转链表（leetcode 206）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverse1</span><span class="params">(ListNode* current,ListNode* pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* temp = current-&gt;next;</span><br><span class="line">    current-&gt;next=pre;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverse1</span>(temp,current);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反转链表注意最后一行代码，return回收数据。</p><hr><h1 id="利用STL迭代器指针进行相互转化"><a href="#利用STL迭代器指针进行相互转化" class="headerlink" title="利用STL迭代器指针进行相互转化"></a>利用STL迭代器指针进行相互转化</h1><h2 id="vector与unordered-set"><a href="#vector与unordered-set" class="headerlink" title="vector与unordered_set"></a>vector与unordered_set</h2><p>给定一个unordered_set，如何将其转化为vector？<br>反之给定一个vector，怎样将其转化为unordered_set?<br>vector&lt; typename &gt; name(初始迭代器，末尾迭代器)；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; nums1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums2</span><span class="params">(nums1.begin(),nums1.end())</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>反之一样成立。注意，把数据存在set中，set自动排序</p><hr><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>最小为O(n),最大为O(n^2)，平均为O(n^2)，空间复杂度O(1),稳定。<br>对于基本排好序的数据来说，插入排序很快。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>最坏复杂度为O(nlogn)，空间复杂度O(1)不稳定。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>最坏为O(nlogn),空间复杂度O(1),不稳定。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>在极端情况下，很有序（正或逆）效率很低。数据很乱就很快。<br>平均复杂度O(nlogn),最坏O(n^2)，空间复杂度O(nlogn)，不稳定。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>平均复杂度O(nlogn),最坏O(n^2),空间复杂度O(n)，稳定。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西藏318！</title>
      <link href="/%E8%A5%BF%E8%97%8F%EF%BC%81/"/>
      <url>/%E8%A5%BF%E8%97%8F%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="国道318旅游小结"><a href="#国道318旅游小结" class="headerlink" title="国道318旅游小结"></a>国道318旅游小结</h1><h2 id="旅游简介"><a href="#旅游简介" class="headerlink" title="旅游简介"></a>旅游简介</h2><p>&emsp;&emsp;什么是国道318？<br>&emsp;&emsp;国道318起于成都市，止于拉萨市，沿着国道318可以走过整个川西线，进藏线，最终两天在拉萨附近游玩。</p><p>&emsp;&emsp;318好玩在哪？<br>&emsp;&emsp;如果你看见过一些北欧比如冰岛的风景，那么318的风景会满足你的一切幻想。无数穿云而出的雪山，在公路上的云雾中穿梭，雪山下碧蓝纯净的圣湖，在国道上漫步的耗牛群，璀璨浩瀚的星河，人迹罕至的原始森林，涛涛怒鸣的江水，悬崖峭壁随处可见，珍稀动物我就拍摄到20余种，以及藏民的风土人情。除此之外，你可以看到人力所致的奇迹—成都搭到拉萨的国家电网，在山坡上的怒江72拐，以及318国道本身就可以说的上是一大奇迹。但同时318又是极其危险的一段旅途，318的美除了经典的景点外，需要自己探索，比如可以把车停下进到原始森林里去看看，看看真正无人触及的自然，真正自然生长的树木，总之越人迹罕至的地方越绝美。318绝对是力压国内所有旅游地点的存在，是我至今去过最好的旅游地点没有之一。</p><h2 id="出行谨记"><a href="#出行谨记" class="headerlink" title="出行谨记"></a>出行谨记</h2><ol><li>318不是自己租车自驾就能走得了的，其一是由于路程遥远，整个318线有2200km，而且大部分公路都是盘在山上的，普通人不熟悉路很难自驾，而且司机出现高反也将是致命的，不要认为整个旅程中海拔是逐渐升高的可以适应，我们第一天结束海拔就已经到达了3500m（拉萨的海拔）；</li><li>危险性：318上的危险因素是多方面的，比如高原反应，有的人在海拔5000米上蹿下跳啥事没有（比如鄙人），有些人到4000米就会呕吐吸氧难以呼吸；比如堵车，318经常性堵车！经常堵车！一首蓝莲花堵在318，你最先看到的绝对不是花海而是车海。318的路很险很崎岖，毫不夸张地说，在旅程的第一天每一个小时就能看到私家车侧翻滚下公路，然后后面的车就会堵死，旅程的第一天大部分时间都堵在路上了，因为前面的事故太多了。还有就是山间的滚石，可以毫不夸张地说，走318会不会出事是看命的，道路两旁都是山崖绝壁。刚进西藏的时候更是抽象，318一侧下方是湍急的河流，另一侧是悬崖绝壁。绝壁上的山岩随时都可能落下，而且318整条路是不存在护栏这类东西的，向下面的河里看可以看到河里密密麻麻全是悬崖上掉落的滚石，在公路上汽车每走一会就会看到新鲜的、砸在路面上还未清理的落石。这些石头小到手掌大小，大到卡车大小，砸到车上就是一起事故。下雨天则各种buff拉满，落石概率大大提升，还有可能解锁泥石流等自然灾害。当时我记得整车的人都是提心吊胆的，手紧握到出汗，生怕绝壁上的石头落下砸到车上。根据司机昊哥自述，上一次走川藏线时就有一块落石把挡风玻璃砸得粉碎。此外318的补给点非常少！相邻的补给点可能距离300km（5小时车程），可以想象一下车上的某个人出现了高反需要吸氧，一个氧气瓶一直吸基本只能吸15min，那么这么长时间的车程阁下又该如何应对呢？318的危险绝对不止以上提到几种，你会真切地感觉到远离文明，拥抱荒蛮的感觉。综上所述，如果自驾的话，你需要大量的金钱，一辆越野车，至少20天时间，提前做好攻略等等，普通人除了报团根本没有任何选择。因此在知道318的危险后，来这里需要一定的勇气，确实是会没命的危险。</li><li>温度：我是在6、7月份出行的，当你查拉萨温度的时候，任何时候基本是最低二十七度。但是问题就出在这里，当你走山路山里开始下雨的时候，阳光光照消失，气温骤降，这种湿冷会使周围空气降低20度，周围气温也就零上几度，严重的会导致失温，因此必须携带薄羽绒服，长裤等保暖衣物。</li><li>辐射：最开始我是没把高原的日晒辐射当一回事的，认为就穿一件防晒服戴个遮阳帽就可以了，结果就是当第八天在羊卓雍错的时候，在海拔4500米太阳光直射而下，我嫌热撸起了防晒服的袖子，结果仅仅过了一中午，双臂露出的部分被烧的火红，达到了辐射受伤的程度（挠一下就会剧痛）。因此防晒服，防晒霜必备，而且尽量要减少被阳光直射，本人目前肤色已从黄色变为黑炭，望诸位引以为戒。</li><li>高反：高反患者可以选择去之前一个月内喝红景天，自备高反药物。至于氧气，土豪可以购买或租借制氧机，平民可以少量携带氧气瓶，不要一直吸，感觉不行了再吸一口。如果发生高反，不要有大幅运动，一切产生吸气需求的运动都会加剧高反，比如正常走路，更不用说登高，跑跳这些行为，甚至是高原上上厕所。发生高反了也不必太慌，找个卫生所吸氧，挺两天。而且建议要乘坐底盘高的车，为什么要坐好车？稳，稳，还是他妈的稳。想想318部分路段本就颠簸，阁下要高反加晕车，我都不敢想，你不吐到死都怪。关于运动方面：本人来之前一直坚持高强度运动，318上并无任何高原反应。因此说来之前停止运动啥的我认为不靠谱，因为高反是因为血红蛋白携带氧气能力不足造成的，来之前几周都不要运动没道理的。</li><li>携带设备：单反相机，无人机，三脚架，自拍杆。无人机没有可以不带，单反你要还不带我都不知道你来318来干嘛。对于摄影爱好者一定要带三角架，因为这里是摄影爱好者的天堂，这里可以拍星空、雪山、花海、圣湖，手机可以带小米13pro及以上能拍到很清晰的银河，详情见我朋友圈。在新都桥的晚上，为了避免道路管控影响行程，我们选择三点启程，一看车窗外卧槽漫天的繁星，抬头仰望夜空直接就能肉眼看到银河。我们用小米13pro照到了清晰的银河核心。海拔4000+以及没有光污染，确实是拍摄银河的最好地点。</li><li>吃住：住的地方不要指望太好，因为都是在一些旅游城镇住宿，环境不会太好，不报团的话住宿价格极高。吃的话进西藏之前主要吃川菜，也有牦牛汤锅等，进西藏之后可以吃藏餐，一般的馆子，价格会稍贵。</li><li>我报的旅游团费用是4680，一共十天。这里注意，想走完整个318必须选10天以上的团，七天的团会感觉到整个旅程都在车上赶路，没时间去玩，那何苦去呢。整个旅程小3000km，自己按车速平均60计算一下就懂了。其他费用加在一起可能8000左右，贵是真的贵，你问我值不值？我是一个惜钱的人，但这次我觉得收我10000我也觉得值得，因为景色实在太美了，就是摄影爱好者的天堂。什么长白山张家界九寨沟，318线在自然风景上力压除新疆之外的所有内陆山水景色。因为你会见到无数巍峨的雪山，如四姑娘山，南迦巴瓦峰等等等等，河流类你能见到金沙江大渡河无量河，湖泊类你会见到姊妹胡、稻城亚丁的牛奶湖五色湖、拉萨的羊湖。峡谷你能看到怒江大峡谷，冰川你能见到米堆冰川，原始丛林只要你下车走进周遭的树林里就是原始丛林。事实证明玩318的过程中，除了最经典的景点，最好玩的永远是人迹罕至之处。推荐的游玩时间是2、3月份（能看到冰川，很多的雪山，但山路易出现事故），6月、7月份初（人少，雪山也没化，温度适宜）。此次旅游我和一个室友碰到了一对新婚夫妻，一个小黑子司机昊哥，简直就是运气爆棚碰到一车对的人，司机熟知318哪里好玩，我们直接跳过一些景点去玩别的地方，看到美景直接停车拍摄，氛围属于是融洽得不能再融洽了。</li><li>携带基础的药品，如感冒药，腹泻药等等。身份证必须随身携带。 必须要结伴而行！起码有个照应。</li><li>整个318行程中遇到了司机昊哥和一对结婚了八个月才度蜜月旅行的新婚夫妻，无论景色还是队友都过于完美欢乐了，但要说整个318旅程中美中不足的地方，我经过认真分析后认为有以下两点：<br>1、在理塘甚至没时间抽上一口芙蓉王；<br>2、进藏忽闻鸡棚塌了，整个丰田普拉多上顿时哀号之声四起，影响了大家后续旅游的兴致。司机昊哥更是过于悲伤，喊着和哥哥不求同年同日生，鸡脚已然是踩不住刹车了，险些直接冲进怒江。</li></ol><h2 id="旅游路线"><a href="#旅游路线" class="headerlink" title="旅游路线"></a>旅游路线</h2><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1:"></a>Day1:</h3><p>从成都出发，基本一天都在堵车，一首蓝莲花堵在318，沿途下起了小雨，云雾缭绕拍了些照，晚上到达了丹巴住下。路上听昊哥讲了很多灵异故事，边开车边放音乐大家一起唱歌才是自驾游的灵魂。<br>住宿：丹巴</p><h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2:"></a>Day2:</h3><p>&emsp;&emsp;早上最先看了亚拉雪山，去了墨石公园，墨石公园的特色在于山的颜色真如石墨一般，特殊的地貌使得游客穿上宇航服，在上中行走仿佛在月亮的山上行走一般。由于鱼子西人太多了又下了雨，路堵死了，我们去了天空之城—格底拉姆，上山就拐了几十个弯路才得以上山，危险至极。山上的美景太绝了，有那种欧式的小屋，铺满石子的小路，有花海，看见了远方雪山的日照金山，日光云影洒在下方群山之中，还有晚上的夕阳西下。<br>住宿：新都桥</p><h3 id="Day3"><a href="#Day3" class="headerlink" title="Day3:"></a>Day3:</h3><p>&emsp;&emsp;到达世界最高城理塘，太美了家人们~！好吧也就那样。过理塘后到达无量河，传说在河里洗一下可以洗去自己之前的罪孽。经过海子山拍了天空之境，还在龙格观景台撒了隆达，晚上到达了稻城外在寺庙边许下了愿望，还拍到了彩虹。<br>住宿：香格里拉</p><h3 id="Day4"><a href="#Day4" class="headerlink" title="Day4:"></a>Day4:</h3><p>&emsp;&emsp;蓝色星球上最后一片净土—稻城亚丁。游亚丁，亚丁门票很贵，但很值，里面是很优美的自然景观，许多雪山，山间的丛林，山涧流水，飞瀑，五色湖，牛奶湖，拍到了好多野生动物，山顶海拔5000米，走的长线+挑战线，全程跑跳没啥问题。这里是真的好看。一天速通亚丁景区。<br>住宿：香格里拉</p><h3 id="Day5"><a href="#Day5" class="headerlink" title="Day5:"></a>Day5:</h3><p>&emsp;&emsp;看到了姊妹湖，姊妹湖依偎在雪山之下，只能远远的看，用无人机拍了一下。这一天主要还是赶路。同一天进藏，进藏的时候路边一侧是湍急的河水，头上是遮蔽日光的绝壁，绝壁上可以看到松动成块的岩石，道路上可以看到没来得及清理掉的新鲜滑下的滚石，险之又险，险象迭生，可以很清晰地感觉到进入到了蛮荒之地。<br>住宿：芒康</p><h3 id="Day6"><a href="#Day6" class="headerlink" title="Day6:"></a>Day6:</h3><p>&emsp;&emsp;星夜启程，看到了满天繁星与银河，拍到了银河核心。东达山垭口东达山垭口海拔5130米，是川藏线需要翻越海拔最高的地方。世界公路史上奇迹—怒江七十二拐，七十二拐是邦达至八宿段的一截悬崖公路，因道路险恶而闻名于世。由于四川境内几座高山隧道全通，通麦、排龙天险业已排除，故尔七十二拐成为川藏线上唯一令人胆战心惊的拦路虎了，经过了怒江72拐，怒江大桥，然乌湖，然乌湖去的时候水不是很清。<br>住宿：波密</p><h3 id="Day7"><a href="#Day7" class="headerlink" title="Day7:"></a>Day7:</h3><p>&emsp;&emsp;去了岗云杉林，但门票太贵感觉不值，就在旁边的林子中拍了拍青稞田；去了嘎朗村周边的一片牧场，给牛喂了些东西，还摸了牛角，很闲静的一片草地。下午去了朗秋冰川，半路去了路边的原始丛林，原始丛林里真的树怪，景怪。人迹罕至之处，景色更是绝美。回波密的时候还拍到了苍穹之光穿云而出。<br>住宿：波密</p><h3 id="Day8"><a href="#Day8" class="headerlink" title="Day8:"></a>Day8:</h3><p>&emsp;&emsp;再次星夜启程，昊哥和我们说了很多当兵的经历，过色季拉山看了南迦巴瓦峰和云海，但是云太多了，后面飞机上拍的弥补了这一遗憾。当天到达拉萨，去了布达拉宫广场，游了八廓街<br>住宿：拉萨</p><h3 id="Day9"><a href="#Day9" class="headerlink" title="Day9:"></a>Day9:</h3><p>&emsp;&emsp;去了羊湖，羊湖实在是绝美，运气好碰到了阳光直射，湖水蓝的和做梦一样。抱了小羊在羊湖拍照还被小羊尿了。水鸟是真多。晚上去了个轻吧喝了两杯，酒吧调的酒确实很好喝，不会使人醉。<br>住宿：拉萨</p><h3 id="Day10："><a href="#Day10：" class="headerlink" title="Day10："></a>Day10：</h3><p>去药王山拿着纸币和布达拉宫拍了照。收拾东西明天回家！<br>住宿：拉萨</p><h2 id="旅游小结"><a href="#旅游小结" class="headerlink" title="旅游小结"></a>旅游小结</h2><p>&emsp;&emsp;我为什么要去318？因为不想走马观花，因为想给青春填上浓墨重彩的一笔，也因为想去别人去不到的地方，做别人做不到的事，还可以体验只存在于想象中的生活。人越少的地方越引人入胜，这一路上除了山河绝美险峻，我更听到，看到了祖国的伟大。听着康定情歌，清晨穿过云雾缭绕的公路，远眺巍峨高耸的雪山，涉足无人知晓的原始森林，俯瞰碧蓝清澈的山间圣湖，雨中漫步在天空之城的花海中，痴迷于夕阳西下的日照金山，夜晚仰望漫天璀璨的繁星，感受着异域城镇的人间烟火，人世间绝景也不过如此。见景洗眼，见人洗心，见到了千金求渡的商贾，也见到了虔诚朝圣的信徒。<br>&emsp;&emsp;在稻城许下了三个愿望后出现了彩虹，在羊湖也抱了可爱的小羊。仿佛过往如云烟一般消散，人世间少了许多疾苦。可以确信的是，人长期处于一种环境之下，会对生命与意义产生不同程度的误判。这也就是为什么要开阔自己的眼界，要见多，要识广。以后有机会也一定要去新疆体验异域风情，去青藏线穿越无人禁区，旅行的作用远远不止调整自己的心态，也能为自己解答不了的问题找到自己答案。318之行是我人生中的一笔财富，美好的回忆会永远熠熠生辉，多年以后也值得细细回味。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>张家界！</title>
      <link href="/%E5%BC%A0%E5%AE%B6%E7%95%8C/"/>
      <url>/%E5%BC%A0%E5%AE%B6%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="张家界游玩规划"><a href="#张家界游玩规划" class="headerlink" title="张家界游玩规划"></a>张家界游玩规划</h1><h2 id="出行"><a href="#出行" class="headerlink" title="出行"></a>出行</h2><p>&emsp;&emsp;往：北京出发坐<font color=DeepSkyBlue size=3 face="黑体">飞机</font> (北京大兴机场-&gt;张家界荷花机场)   </p><ol><li>往返价格：￥774</li><li>单次耗时6h，时间从15：55 — 21:55<br>PS：夏季：夏天的张家界自然是避暑休闲的好去处，可以漂流</li></ol><hr><h2 id="具体住宿位置、景点"><a href="#具体住宿位置、景点" class="headerlink" title="具体住宿位置、景点"></a>具体住宿位置、景点</h2><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>张家界西站旁边民宿</p><h2 id="旅游地点"><a href="#旅游地点" class="headerlink" title="旅游地点"></a>旅游地点</h2><p>&emsp;&emsp;<font color=red size=4 face="黑体">主景点：</font><br>&emsp;&emsp; 两个5A级景区： <font color=DeepSkyBlue size=3 face="黑体">张家界武陵源风景名胜区、张家界天门山国家森林公园 </font><br>&emsp;&emsp;<font color=red size=4 face="黑体">其他：</font><br>&emsp;&emsp;黄龙洞、张家界大峡谷、红石林  </p><hr><h2 id="时间及路线安排"><a href="#时间及路线安排" class="headerlink" title="时间及路线安排"></a>时间及路线安排</h2><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>&emsp;&emsp;<font color=DeepSkyBlue size=3 face="黑体">黄龙洞+张家界峡谷 </font> (游览时间1day)</p><hr><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>&emsp;&emsp;<font color=DeepSkyBlue size=3 face="黑体">张家界武陵源风景名胜区 </font> (游览时间1day)<br><img src="/img/wulingl.png" alt="s"><br>门票：￥237<br>PS：张家界国家森林公园（不是张家界天门山国家森林公园）和张家界武陵源风景名胜区是一个地方。<br>&emsp;&emsp;<font color=red size=3 face="黑体">游玩顺序1</font>：武陵源标志门票站(环保车)-&gt;天子山索道上天子山-&gt;袁家界→百龙天梯-&gt;48将军岩-&gt;金鞭溪-&gt;回<br>&emsp;&emsp;<font color=red size=3 face="黑体">游玩顺序2</font>：武陵源标志门票站(环保车)-&gt;十里画廊-&gt;-&gt;袁家界→百龙天梯-&gt;48将军岩-&gt;天子山-&gt;回<br>&emsp;&emsp;<font color=red size=3 face="黑体">游玩顺序3</font>：森林公园门票站-&gt;金鞭溪-&gt;袁家界-&gt;百龙天梯-&gt;48将军岩-&gt;天子山-&gt;回<br>【袁家界】：百龙天梯、48将军岩、天下第一桥、哈利路亚山、迷魂台<br>【天子山】：空中田园、贺龙公园、天子峰<br>【金鞭溪】：7km、氧吧</p><hr><h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p>上午：<br>&emsp;&emsp;<font color=DeepSkyBlue size=3 face="黑体">张家界天门山国家森林公园 </font>  (游览时间4h)</p><p>&emsp;&emsp;票价:275 (双程索道+扶梯)、232（单程索道+扶梯）<br><img src="/img/tianmen1.png" alt="景区地图"></p><p><font color=red size=3 face="黑体">PS2:想爬999步天梯，A线、B线都可以。 </font><br>&emsp;&emsp;A线流程：张家界市区索道站（门票售票窗口）入口，大索道上山→山顶游览→玻璃栈道→穿山扶梯（下行）→天门洞→通天大道（999层台阶）→快线索道下山→后山停车场→景区环保车→市区索道站（停车场）<br>&emsp;&emsp;B 线流程： 张家界市区索道站（门票售票窗口）入口，环保车上山→后山停车场→快线索道上山→天门洞广场→通天大道（999层台阶）→天门洞→穿山扶梯（上行）→玻璃栈道→山顶游览→大索道下山→市区索道站（停车场） </p><p><font color=red size=3 face="黑体">PS3:只需要参考两条线的缆车，扶梯次序 </font><br>到山上：走西线，上<font color=DeepSkyBlue size=3 face="黑体">玻璃栈道 </font> -&gt;<font color=DeepSkyBlue size=3 face="黑体">天门山索桥 </font>（40min）<br>西线结束：此时到达天门山寺，两个选择，云梦仙顶/东线<br>东线：爱情桥-&gt;南府天门-&gt;爱情桥-&gt;玉壶峰（跳伞）-&gt;北府天门（50min）<br>东线之后可以去云梦仙顶或下山。</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><h3 id="第四天上午"><a href="#第四天上午" class="headerlink" title="第四天上午"></a>第四天上午</h3><hr><h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><ol><li>照相机！</li><li>火车是充氧列车，确定氧气袋受否需要提前少量购买以及抑制高原反应的药物</li><li>及时购买返程车票</li><li>保暖衣物</li><li>一个轻薄本</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三大语言的跨平台开发总结</title>
      <link href="/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
      <url>/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><font color=red size=5 face="黑体">Ask:</font>跨平台指的是C++程序编译后的可执行文件如 main.o可以直接复制到windows或linux上，并且可以正常运行吗？</p><p><font color=DeepSkyBlue size=5 face="黑体">Answer:</font><br>在理论上，将C++程序的编译后的可执行文件（例如 main.o）从一个平台复制到另一个平台可能会面临以下问题：</p><p>二进制兼容性：不同操作系统和硬件架构使用不同的二进制文件格式和指令集。因此，将一个平台上编译的二进制文件直接复制到另一个平台可能无法识别或执行。</p><p>依赖项和运行时环境：可执行文件可能依赖于特定的库文件、操作系统功能、动态链接器等。如果目标平台上缺少这些依赖项或运行时环境不兼容，那么可执行文件可能无法正常运行。</p><p>系统调用和文件路径：不同的操作系统使用不同的系统调用和文件路径规范。如果程序在一个平台上使用了特定于该平台的系统调用或文件路径，而在目标平台上这些调用或路径不可用或不同，那么程序可能会出现错误或无法正常工作。</p><p>综上所述，将C++程序的编译后的可执行文件直接从一个平台复制到另一个平台并不保证能够直接运行。在跨平台部署时，通常需要重新编译可执行文件以适应目标平台的架构、依赖项和运行时环境，并进行适当的修改以处理不同操作系统的差异。</p><p><font color=red size=5 face="黑体">Ask:</font><br>就是说我在windows上的QT开发了一款应用软件，将这个应用软件复制到linux系统上，会出现二进制不兼容问题吗？</p><p><font color=DeepSkyBlue size=5 face="黑体">Answer:</font><br>当你在Windows上使用Qt开发应用软件时，将生成的可执行文件复制到Linux系统上可能会出现二进制不兼容的问题。这是由于Windows和Linux使用不同的操作系统、不同的二进制文件格式以及不同的系统调用和库的差异所导致的。</p><p>在Windows上编译的可执行文件通常使用PE（Portable Executable）格式，而Linux上使用的是ELF（Executable and Linkable Format）格式。这两种格式是不兼容的，因此无法直接在不同的操作系统上运行。</p><p>此外，Linux和Windows上的系统调用和库也存在差异。如果你的应用程序依赖于特定于Windows的系统调用、库或功能，这些在Linux上可能是不可用的或与Windows上的版本不兼容。</p><p>为了在Linux系统上运行你的应用程序，通常需要在Linux上重新编译你的源代码，并使用适用于Linux的编译器和工具链进行构建。这样可以确保生成适用于Linux的可执行文件，同时处理平台差异和依赖项的问题。</p><p>虽然Qt为跨平台开发提供了很大的便利性，但仍需要在目标平台上进行适当的编译和部署，以确保软件能够在该平台上正常运行。</p><p><font color=red size=5 face="黑体">Ask:</font><br>JAVA程序的跨平台也是指代码得在另一个操作系统上重新由JVM解释和执行才可以，而不是把可执行文件粘贴过去就能用？</p><p><font color=DeepSkyBlue size=5 face="黑体">Answer:</font><br>是的，你的理解是正确的。在Java中，跨平台性是指你的Java代码需要在目标操作系统上重新由JVM解释和执行，而不是简单地将可执行文件复制到另一个操作系统上。</p><p>Java程序通过编译成字节码（.class 文件），这是一种平台无关的中间代码。然后，目标操作系统上的Java虚拟机（JVM）将解释和执行这些字节码。JVM根据具体的操作系统和硬件架构来提供适当的运行环境。</p><p>当你将Java程序的字节码文件（.class 文件）复制到另一个操作系统上时，该操作系统上需要安装适当版本的Java虚拟机（JVM）。JVM会读取并解释字节码，并将其转换为适用于该操作系统的本地机器码，从而执行Java程序。</p><p>因此，跨平台性意味着你可以将Java程序的字节码文件在不同的操作系统上运行，只要目标操作系统上安装了相应的JVM。这样的设计使得Java具有很好的可移植性和兼容性，但仍需要在目标操作系统上提供适当的运行时环境。</p><p>总结而言，Java程序的跨平台性是指你的Java代码在目标操作系统上需要由JVM重新解释和执行，而不是简单地复制可执行文件。这种跨平台性是通过JVM提供的中间层实现的，它在不同的操作系统上提供了统一的运行环境。</p><p><font color=red size=5 face="黑体">Ask:</font><br>那C++中的汇编文件是与中间平台无关的代码吗？</p><p><font color=DeepSkyBlue size=5 face="黑体">Answer:</font><br>C++中的汇编文件（.s 或 .asm 文件）包含了汇编语言代码，它是与特定的硬件架构相关的低级代码。汇编语言是一种与机器码相对应的人类可读的低级语言，用于直接操作计算机的指令集和寄存器。</p><p>汇编文件通常与特定的处理器架构相关，因此与中间平台无关。这意味着汇编文件本身不具备跨平台性。在不同的硬件架构上，汇编文件需要适应不同的指令集和寄存器，因此不能直接在不同的平台上使用相同的汇编文件。</p><p>要使汇编文件在不同的平台上工作，需要根据目标平台的架构和指令集进行适当的修改和调整。这通常需要编写针对特定平台的不同汇编代码，以确保正确地使用该平台的指令和寄存器。</p><p>然而，需要注意的是，C++代码编译成的目标文件（例如，ELF格式的文件）是与平台相关的。目标文件包含了机器码和与特定平台相关的信息，如符号表、重定位表等。因此，即使使用C++编写的源代码是跨平台的，但编译生成的目标文件通常是与特定平台相关的。</p><p>总结起来，C++中的汇编文件是与特定的硬件架构相关的低级代码，并且与中间平台无关。然而，汇编文件本身并不具备跨平台性，需要根据不同平台的指令集和寄存器进行适当的修改。编译生成的目标文件是与特定平台相关的。</p><p><font color=red size=5 face="黑体">Ask:</font><br>那python的跨平台开发呢？</p><p><font color=DeepSkyBlue size=5 face="黑体">Answer:</font><br>Python是一种解释型语言，它的跨平台性非常强。Python的跨平台性是由于以下几个方面的特点：</p><p>解释型语言：Python是一种解释型语言，它的源代码在运行之前不需要编译成机器码。Python解释器会在运行时逐行解释执行代码。由于解释器的存在，Python程序可以在任何安装了Python解释器的操作系统上运行，无需重新编译。</p><p>跨平台的Python解释器：Python解释器本身是跨平台的。它提供了针对各种操作系统的不同版本，例如Windows、Linux、macOS等。你可以选择适用于目标平台的Python解释器进行安装和使用。</p><p>统一的标准库：Python具有丰富的标准库，其中包含了大量的功能模块和工具，可以在不同的操作系统上通用地使用。这些标准库对于Python的跨平台开发提供了很大的便利性，因为它们提供了一致的API和功能，使得你可以在不同的操作系统上编写相同的代码。</p><p>第三方库和框架：Python拥有庞大的第三方库和框架生态系统，提供了各种用于跨平台开发的工具和库。这些库和框架可以帮助你处理不同平台的差异，提供了跨平台开发的解决方案。</p><p>总而言之，Python具有很好的跨平台性，你可以在不同的操作系统上运行相同的Python代码，而无需进行额外的修改或重新编译。这使得Python成为一种流行的选择，特别是在跨平台应用程序开发、脚本编写和数据分析等领域。</p><p><font color=red size=5 face="黑体">Ask:</font><br>那在windows上用python开发的软件复制粘贴到linux系统就可以直接运行吗</p><p><font color=DeepSkyBlue size=5 face="黑体">Answer:</font><br>在Windows上使用Python开发的软件不能直接复制粘贴到Linux系统上并直接运行。尽管Python本身是跨平台的，但在不同的操作系统上仍然存在一些差异和依赖关系需要处理。</p><p>下面是一些需要考虑的关键点：</p><p>Python解释器：确保目标Linux系统上已经安装了适当版本的Python解释器。不同的Linux发行版和版本可能会预装不同的Python版本，因此需要确保Python解释器的兼容性。</p><p>依赖库和模块：你的Python软件可能依赖于各种第三方库和模块。在将软件从Windows复制到Linux时，需要确保目标系统上已经安装了相应的依赖项，包括特定版本的库和模块。</p><p>文件路径和操作系统差异：在代码中使用的文件路径、操作系统相关的功能调用以及其他平台特定的功能可能会有差异。你需要确保代码在Linux系统上适应正确的文件路径格式和操作系统调用。</p><p>脚本解释器头部：在Python脚本的顶部通常会包含一个指定脚本解释器的头部声明，例如 #!/usr/bin/env python。在将脚本从Windows复制到Linux时，需要确保头部声明正确指向目标系统上的Python解释器路径。</p><p>因此，尽管Python具有跨平台的特性，但在将Python软件从一个操作系统复制到另一个操作系统时，仍然需要进行一些调整和配置，以适应目标系统的环境和要求。确保目标系统上已经安装了适当的Python解释器和依赖项，并对代码进行必要的修改，才能确保软件能够在Linux系统上正确运行。</p>]]></content>
      
      
      <categories>
          
          <category> 软硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cMake总结</title>
      <link href="/cMake/"/>
      <url>/cMake/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在了解cMake之前，可以从本站博客《操作系统发展简史》先了解一下GNU，GCC,g++,gcc的区别</p><h1 id="如何使用cMake"><a href="#如何使用cMake" class="headerlink" title="如何使用cMake"></a><font color=DeepSkyBlue size=5 face="黑体">如何使用cMake</font></h1><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>&emsp;&emsp;你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。CMake 就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>写 CMake 配置文件 CMakeLists.txt 。</li><li>执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile（ccmake 和 cmake 的区别在于前者提供了一个交互式的界面）。其中， PATH 是 CMakeLists.txt 所在的目录。</li><li>使用 make 命令进行编译。<br>例子：</li></ol><p><font color=YellowGreen>mian.c</font><br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = base;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s base exponent \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> base = atof(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> exponent = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">double</span> result = power(base, exponent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g ^ %d is %g\n&quot;</span>, base, exponent, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color=DeepSkyBlue size=5 face="黑体">编写 CMakeLists.txt</font><br>&emsp;&emsp;首先编写 CMakeLists.txt 文件，并保存在与 main.c 源文件同个目录下：</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cc)</code></pre><p>&emsp;&emsp;CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><ol><li>cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本；</li><li>project：参数值是 Demo1，该命令表示项目的名称是 Demo1 。</li><li>add_executable：将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件。</li></ol><p><font color=DeepSkyBlue size=5 face="黑体">指定C++标准</font><br>    C++ 语言有不同版本的标准，如 C++ 98、C++ 11、C++ 14 等。不同标准提供的特性有所区别，故有必要在 CMakeLists.txt 中为项目指定使用何种标准，进而让 CMake 使用正确的编译器标志（比如 -std=c++11）。对于 CMake v3.1 以上版本，可以通过 CMAKE_CXX_STANDARD 变量指定标准，或通过 target_compile_features 函数根据使用的特性自动推断适用于目标的编译器标志。</p><pre><code>cmake_minimum_required(VERSION 3.15)# set the project name and versionproject($&#123;PROJECT_NAME&#125; VERSION 1.0)# specify the C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)</code></pre><p><font color=red size=4 face="黑体">强制指定C++标准</font><br>&emsp;&emsp;出于对编译器的兼容性之考虑，上面这种设置标准的方法并不是强制执行。假设某个项目设置使用 C++ 11 标准，但用户使用的编译器并不支持 -std=gnu++11 （或等价的）标志，将不会导致错误或警告，而是在允许的情况下添加 -std=gnu++98 标志。换言之，CMake 将自动“衰减”至最接近的标准。如果确实需要强制指定标准，禁用这种自动衰减调整，那么可以通过设置 CXX_STANDARD_REQUIRED 实现。</p><p>&emsp;&emsp;CXX_STANDARD_REQUIRED 是一个布尔类型的变量，用于描述是否需要（强制）指定 CXX_STANDARD。当打开此选项，且当前使用的编译器不支持指定的标准时，会在 configuring 阶段报错失败，不会进行编译。</p><p>对上一节中的小例子稍加修改，使其强制使用 C++ 11 标准：</p><pre><code>cmake_minimum_required(VERSION 3.1)project (hello_cpp11)set(CMAKE_CXX_STANDARD 11)  # 将 C++ 标准设置为 C++ 11set(CMAKE_CXX_STANDARD_REQUIRED ON)  # C++ 11 是强制要求，不会衰退至低版本add_executable(hello_cpp11 main.cpp)</code></pre><p><font color=DeepSkyBlue size=5 face="黑体">编译项目</font><br>&emsp;&emsp;之后，在当前目录执行 cmake . ，得到 Makefile 后再使用 make 命令编译得到 Demo1 可执行文件。</p><pre><code>[ehome@xman Demo1]$ cmake .-- The C compiler identification is GNU 4.8.2-- The CXX compiler identification is GNU 4.8.2-- Check for working C compiler: /usr/sbin/cc-- Check for working C compiler: /usr/sbin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working CXX compiler: /usr/sbin/c++-- Check for working CXX compiler: /usr/sbin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Configuring done-- Generating done-- Build files have been written to: /home/ehome/Documents/programming/C/power/Demo1[ehome@xman Demo1]$ makeScanning dependencies of target Demo[100%] Building C object CMakeFiles/Demo.dir/main.cc.oLinking C executable Demo[100%] Built target Demo[ehome@xman Demo1]$ ./Demo 5 45 ^ 4 is 625[ehome@xman Demo1]$ ./Demo 7 37 ^ 3 is 343[ehome@xman Demo1]$ ./Demo 2 102 ^ 10 is 1024</code></pre><p><font color=DeepSkyBlue size=5 face="黑体">同一目录，多个源文件</font><br>&emsp;&emsp;上面的例子只有单个源文件。现在假如把 power 函数单独写进一个名为 MathFunctions.c 的源文件里，使得这个工程变成如下的形式：</p><pre><code>./Demo2    |    +--- main.c    |    +--- MathFunctions.c    |    +--- MathFunctions.h</code></pre><p>&emsp;&emsp;这个时候，CMakeLists.txt 可以改成如下的形式</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 指定生成目标add_executable(Demo main.cc MathFunctions.c)</code></pre><p>&emsp;&emsp;唯一的改动只是在 add_executable 命令中增加了一个 MathFunctions.c 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><pre><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code></pre><p>&emsp;&emsp;因此，可以修改 CMakeLists.txt 如下：</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;)</code></pre><p>&emsp;&emsp;这样，CMake 会将当前目录所有源文件的文件名赋值给变量 DIR_SRCS ，再指示变量 DIR_SRCS 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p><p><font color=DeepSkyBlue size=5 face="黑体">多个目录，多个源文件</font><br>&emsp;&emsp;现在进一步将 MathFunctions.h 和 MathFunctions.c 文件移动到 math 目录下。</p><pre><code>./Demo3    |    +--- main.cc    |    +--- math/        |        +--- MathFunctions.cc        |        +--- MathFunctions.h</code></pre><p>&emsp;&emsp;对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。根目录中的 CMakeLists.txt ：</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo3)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)# 指定生成目标 add_executable(Demo main.cc)# 添加链接库target_link_libraries(Demo MathFunctions)</code></pre><p>&emsp;&emsp;该文件添加了下面的内容: 第3行，使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。子目录中的 CMakeLists.txt：</p><pre><code># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 生成链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</code></pre><p>&emsp;&emsp;在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。</p><h2 id="QMake"><a href="#QMake" class="headerlink" title="QMake"></a>QMake</h2><ol><li>接着是qmake，qmake是什么，先说一下Qt这个东西。Qt是跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。简单的说就是C++的第三方库，使用这个库你可以很容易生成windows，Linux，MAC os等等平台的图形界面。现在的Qt还包含了开发各种软件一般需要用到的功能模块（网络，数据库，XML，多线程啊等等），比你直接用C++（只带标准内裤那种）要方便和简单。</li><li>你可以用Qt简简单单就实现非常复杂的功能，是因为Qt对C++进行了扩展，你写一行代码，Qt在背后帮你写了几百上千行，而这些多出来的代码就是靠Qt专有的moc编译器（The Meta-Object Compiler）和uic编译器（User Interface Complier）来重新翻译你那一行代码。问题来了，你在进行程序编译前就必须先调用moc和uic对Qt源文件进行预处理，然后再调用编译器进行编译。上面说的那种普通makefile文件是不适用的，它没办法对qt源文件进行预处理。所以qmake就产生了。</li><li>qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。</li><li>qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。</li><li>还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -= qt  就可以了。</li><li>那这样qmake和cmake有什么区别？不好意思，cmake也是同样支持Qt程序的，cmake也能生成针对qt 程序的那种特殊makefile，只是cmake 的CMakeLists.txt 写起来相对与qmake的pro文件复杂点。qmake 是为 Qt 量身打造的，使用起来非常方便，但是cmake功能比qmake强大。一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的。当你的工程非常大的时候，又有qt部分的子工程，又有其他语言的部分子工程，据说用cmake会方便。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM十四讲之3</title>
      <link href="/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B3/"/>
      <url>/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B3/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;ch3的基本知识还不算难，这里注意向量<font color=red size=3 face="黑体">p</font>在某坐标系下的坐标指的是p点到原点的向量在这个坐标系的单位正交基向量下的表示。例如<font color=red size=3 face="黑体">p</font>= e1a1+e2a2+e3a3 。其中e1,e2,e3为单位正交基向量，那么（a1,a2,a3）就是坐标值。高翔的书解释不是很清楚，此为大坑！<br>&emsp;&emsp;剩下的就是跑程序的事情了。由于cMake理解的不透彻，vscode不太会用，debug一下午一晚上，cMake属实是不会是真不会，会了真简单。</p><p><font color=DeepSkyBlue size=5 face="黑体">如何CMAKE</font><br>&emsp;&emsp;在一个大型程序中，经常出现一个大项目中包含了许多小工程文件夹，除了总工程有个汇总的CMAKElist.txt，每个小工程文件夹都有自己的CMAKElist.txt。</p><p><font color=YellowGreen size=3 face="黑体">如何CMAKE？</font>首先安装CMAKE，之后在cMakelist.txt同级并列建一个build文件夹，在build文件夹中执行以下代码</p><pre><code>cmake ..make./生成的可执行文件</code></pre><p>&emsp;&emsp;cmake ..是回到与build文件夹平级的目录下找cMakelist.txt文件。build文件夹的作用是装中间生成的文件，避免项目内容杂乱。</p><p><font color=DeepSkyBlue size=5 face="黑体">如何安装github上的库？</font><br>在ubuntu系统中，在想要下载的文件夹下</p><pre><code>git clone http...... .git</code></pre><p>下载以后安装依赖：<br>    sudo apt-get install libglew-dev<br>    sudo apt-get install cmake<br>    sudo apt-get install libboost-dev libboost-thread-dev libboost-filesystem-dev</p><p>安装pangolin</p><pre><code>cd Pangolinmkdir buildcd buildcmake ..makesudo make install</code></pre><p>卸载pangolin:在build文件夹下</p><pre><code>sudo make uninstall</code></pre><p><font color=DeepSkyBlue size=5 face="黑体">出现同类型相同异常报错</font><br>这种错误一般出自两个方面：<br>1、缺少相关的依赖和库<br>2、库、编译器、cMake版本不协调。<br>本节项目中，要用到c++14而不是c++11。<br>C++ 的国际标准有 5 个版本，1998, 2003, 2011, 2014, 2017<br>最新的 C++20 截至目前还没正式出版。C++03 是给 C++98 打的补丁，所以现在的人提到 C++98, C++03 往往指的是同一个。</p><p><font color=DeepSkyBlue size=5 face="黑体">ldconfig指令的作用</font><br>1、ldconfig是一个动态链接库管理命令，其目的为了让动态链接库为系统所共享。<br>2、ldconfig的主要用途：<br>&emsp;&emsp;默认搜寻/lilb和/usr/lib，以及配置文件/etc/ld.so.conf内所列的目录下的库文件。<br>&emsp;&emsp;搜索出可共享的动态链接库，库文件的格式为：lib<strong>*.so.</strong>，进而创建出动态装入程序(ld.so)所需的连接和缓存文件。<br>&emsp;&emsp;缓存文件默认为/etc/ld.so.cache，该文件保存已排好序的动态链接库名字列表。<br>&emsp;&emsp;ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</p><p>ldconfig需要注意的地方：</p><p>1、往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf文件的，但是添加完后需要调用下ldconfig，不然添加的library会找不到。<br>2、如果添加的library不在/lib和/usr/lib里面的话，就一定要修改/etc/ld.so.conf文件，往该文件追加library所在的路径，然后也需要重新调用下ldconfig命令。比如在安装MySQL的时候，其库文件/usr/local/mysql/lib，就需要追加到/etc/ld.so.conf文件中。命令如下：<br>%# echo “/usr/local/mysql/lib” &gt;&gt; /etc/ld.so.conf<br>%# ldconfig -v | grep mysql<br>3、如果添加的library不在/lib或/usr/lib下，但是却没有权限操作写/etc/ld.so.conf文件的话，这时就需要往export里写一个全局变量LD_LIBRARY_PATH，就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM</title>
      <link href="/SLAM/"/>
      <url>/SLAM/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/forest.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><p>&emsp;&emsp;在大兴和凯翔进行了一次长谈，关于以后找工作、实验室的优势以及劣势，发现没有一技之长的话那么知名可靠的私企就很难进了。在广泛地观察与询问之后，我决定将学习方向锁定在C++与SLAM上，一方面因为前后端、算法这些岗位没有学习成本，就业人口基数过大；另一方面因为SLAM结合了计算机视觉、传感器基础、后端的滤波、算法优化等，这些都还算是本科都有涉及，最后还可以和嵌入式集成开发。</p><p>&emsp;&emsp;S.L.A.M.全称为Simultaneous Localization and Mapping，是以定位和建图两大技术为目标的一个研究领域。目前主流的slam技术应用为激光slam(基于激光雷达)和视觉slam(基于单/双目摄像头)，实现上主要分为基于滤波 （Filter-Based） 的SLAM，和基于图优化（Graph-Based）的SLAM。归结其本质，其实就是—-State Estimation in Robotics。</p><p><font color=DeepSkyBlue size=5 face="黑体">SLAM做的主要是以下几件事：</font><br><img src="/img/SLAM.png" alt=""> </p><p><font color=YellowGreen size=3 face="黑体">传感器信息读取：</font>在视觉SLAM中主要为相机图像信息的读取和预处理。如果是机器人中，还可能是码盘、惯性传感器等信息的读取和同步。</p><p><font color=YellowGreen size=3 face="黑体">前端视觉里程计（Visual Odometry，VO）：</font>视觉里程计的任务是估算相邻图像间相机的运动，以及局部地图的样子，又称为前端（Front End）。</p><p><font color=YellowGreen size=3 face="黑体">后端非线性优化（Optimization）：</font>后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对他们进行优化，得到全局一致的地图。由于在VO之后，又被称为后端（Back End）。</p><p><font color=YellowGreen size=3 face="黑体">回环检测（Loop Closure Detection）：</font>回环检测机器人是否到达过先前的位置，如果检测到回环，它会把信息提供给后端进行处理。</p><p><font color=YellowGreen size=3 face="黑体">建图（mapping）：</font>它根据估计的轨迹，建立与任务要求对应的地图。</p><p>&emsp;&emsp;其中前端前端相当于VO（视觉里程计），研究帧与帧之间变换关系。首先提取每帧图像特征点，利用相邻帧图像，进行特征点匹配，然后利用RANSAC去除大噪声，然后进行匹配，得到一个pose信息（位置和姿态），同时可以利用IMU（Inertial measurement unit惯性测量单元）提供的姿态信息进行滤波融合后端则主要是对前端出结果进行优化，利用滤波理论（EKF、UKF、PF）、或者优化理论TORO、G2O进行树或者图的优化。最终得到最优的位姿估计。<br>&emsp;&emsp;后端这边难点比较多，涉及到的数学知识也比较多，总的来说大家已经慢慢抛弃传统的滤波理论走向图优化去了。因为基于滤波的理论，滤波器稳度增长太快，这对于需要频繁求逆的EKF（扩展卡尔曼滤波器），PF压力很大。而基于图的SLAM，通常以keyframe（关键帧）为基础，建立多个节点和节点之间的相对变换关系，比如仿射变换矩阵，并不断地进行关键节点的维护，保证图的容量，在保证精度的同时，降低了计算量。</p><p>SLAM十四讲理论部分主要分为以下几个部分：</p><p><font color=DeepSkyBlue>第三讲 三维空间的刚体运动</font><br>![四元数的可视化：]<a href="https://www.bilibili.com/video/BV1SW411y7W1/?spm_id_from=333.999.0.0&amp;vd_source=293eb9377444f6b649cc1019a16b1a8a">https://www.bilibili.com/video/BV1SW411y7W1/?spm_id_from=333.999.0.0&amp;vd_source=293eb9377444f6b649cc1019a16b1a8a</a><br>![欧拉角万向死锁现象：]<a href="https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.999.0.0</a></p><p><font color=LightSeaGreen>第四讲 李群和李代数</p><p><font color=red>第五讲 相机与图像</p><p><font color=DeepPink>第六讲 非线性优化</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理任务</title>
      <link href="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1/"/>
      <url>/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/ali1.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><p>&emsp;&emsp;任务来源：peng’s 毕设project<br>&emsp;&emsp;任务描述：一个问答聊天系统，前端输入聊天信息，交付给内置自然语言处理模型的后端服务器处理，并将处理结果交付给前端。<br>实现的条件：本机上Tomcat服务器，本机上FlaskServer服务器：pycharm专业版上运行。两个服务器运行在本机上，占用某些端口实现功能。</p><p>&emsp;&emsp;各部分功能：<br>&emsp;&emsp;Tomcat服务器：搭载前端的静态网页，当用户使用浏览器访问网页时将.html文件发送给用户的浏览器；将用户与前端交互的内容（如消息内容，HTTP信号）发送给后端服务器。<br>&emsp;&emsp;FlaskServer服务器:由pycharm导入的flask框架构建的极简服务器，占用了电脑上的三个端口来完成后端的处理任务。任务包括：前端打包的解析网页服务请求，交互数据信息；利用训练好的模型实现对信息的实体识别，关系提取等NLP特长；将处理得到的结果融合Neo4j数据库的知识图谱作为聊天的回答返回给前端界面。<br><img src="/img/Tom.png" alt="Tomcat"></p><p>&emsp;&emsp;Tomcat服务器介绍：<br>&emsp;&emsp;Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。<br>&emsp;&emsp;诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另 外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP 容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache 服务器。目前Tomcat最新版本为9.0。<br>&emsp;&emsp;Tomcat服务器配置：<br>&emsp;&emsp;烂大街了，默认8080端口是静态网页放置的端口，需要注意的是，需要由JAVA的运行环境，即Java JDK。Java JDK上链接：<br>&emsp;&emsp;<a href="https://blog.csdn.net/Fly_1213/article/details/101750887">https://blog.csdn.net/Fly_1213/article/details/101750887</a><br>&emsp;&emsp;需要用到Java 开发环境的原因是tomcat是用java写的，所以运行需要JRE，就是JAVA运行时刻环境，所以必须通过安装JDK来得到这个运行环境。Tomcat为什么要配置java jdk原文链接：<br>&emsp;&emsp;<a href="https://blog.csdn.net/qq_42257666/article/details/105700638">https://blog.csdn.net/qq_42257666/article/details/105700638</a><br>Tomcat的初始配置也几乎都是给Tomcat提供javaJDK的路径。这样就引出了更深层次的问题：为什么有的应用程序不需要配置，Tomcat则需要配置？<br>&emsp;&emsp;这是因为Windows版本的JDK安装以后会将安装的路径写入系统的注册表里边的。很多程序不用配置JAVA_HOME是因为那些程序是直接通过读取注册表里边的路径获取了JDK的路径，写到相应的配置文件中，比如Eclipse和Netbeans。<br>&emsp;&emsp;而Tomcat显然没有这样去处理，只是简单地通过环境变量去获取JDK的路径，所以要运行Tomcat一般都是要配置环境变量的。Tomcat这样做也是出于跨平台考虑的。因为系统注册表是只有Windows系统才有的，Linux系统是没有系统注册表的，所以为了跨平台性，Tomcat选择了需要手动配置环境变量。当有请求时,Tomcat会自动将jsp里面的java程序部分提取出来，调用JDK将java程序编译成class，然后再执行这个class。<br>&emsp;&emsp;Tomcat的使用与作用：<br>&emsp;&emsp;<a href="https://zhuanlan.zhihu.com/p/440916459">https://zhuanlan.zhihu.com/p/440916459</a><br>&emsp;&emsp;<br><img src="/img/Tomcat_url.png" alt="Tomcat内容"></p><p>&emsp;&emsp;flaskServer介绍：<br>&emsp;&emsp;Flask是一个Python编写的Web 微框架，让我们可以使用Python语言快速实现一个网站或Web服务，在介绍Flask之前首先来聊下它和Django的联系以及区别，django个大而全的web框架，它内置许多模块，flask是一个小而精的轻量级框架，Django功能大而全，Flask只包含基本的配置, Django的一站式解决的思路，能让开发者不用在开发之前就在选择应用的基础设施上花费大量时间。Django有模板，表单，路由，基本的数据库管理等等内建功能。与之相反，Flask只是一个内核，默认依赖于2个外部库： Jinja2 模板引擎和 WSGI工具集—Werkzeug , flask的使用特点是基本所有的工具使用都依赖于导入的形式去扩展，flask只保留了web开发的核心功能。<br>&emsp;&emsp;FlaskServer配置：<br>&emsp;&emsp;由于是搭载在pycharm上的，导入flask框架的.py文件直接运行（配置flask运行环境），或者直接建立flask项目都是可以运行起务器的。并且要设定本机的哪些端口给FlaskServer服务器使用。可以在代码中，也可以在运行配置中。</p><p>&emsp;&emsp;实现描述：<br>&emsp;&emsp;首先运行Tomcat bin文件夹下的startup.bat文件（如果添加到系统路径直接cmd输入startup运行），将已经设计好的前端静态页面运行在本机8080端口上，此时打开浏览器访问 <a href="http://localhost:8080/HistoryWeb/main.html">http://localhost:8080/HistoryWeb/main.html</a> 就可以看到如下的静态页面。<br><img src="/img/web.png" alt="静态页面"></p><p>&emsp;&emsp;运行flask相当于启动了后端，聊天系统网页功能启动。在pycharm上用右上角的flask运行，而不用python解释器的运行，这里是由于flask实现后端监听函数的功能只需要路由函数，即@app.route(‘/ner’)下的函数，用flask运行时.py文件不会去运行if <strong>name</strong> == ‘<strong>main</strong>‘:下的主函数，而会直接运行路由函数。</p><p>&emsp;&emsp;之后就可以在前端输入text文本，前端服务器Tomcat将text文本和HTTP/kbqa请求发送给后端FlaskServer的5002端口,FlaskServer的5002端口上运行的kbqa.py程序监听到了HTTP/kbqa请求，便会运行.kbqa文件的对应路由函数，创建两个线程分别发送/ner，/ccr请求给另外两个端口。predict.py和server.py分别运行在这两个端口上监听请求，收到请求后分别执行实体识别和关系分类。联系Neo4j数据库中的知识图谱内容将回答语句处理完毕后发回前端从而实现聊天。<br><img src="/img/neoj4.png" alt="数据库内容"><br>&emsp;&emsp;注意本例中FlaskServer服务器的程序监听5002端口，接收到前端的信息后，发送将NER（实体识别）和CRR（关系提取）的请求请求转发给Flask服务器的不同端口来处理文本。现实中服务器可以使用同一个端口处理不同的请求，但在本例中，FlaskServer服务器开放了两个端口监听不同的请求，而Flask服务器分别创建了5000和5001两个端口的线程来处理不同的请求，分别处理NER（实体识别）和CRR（关系提取）的请求，使用不同的端口的好处是可以更好地区分不同的请求，方便调试和管理。另外，使用不同的端口还可以允许不同的服务在同一台服务器上运行，避免端口冲突。</p><p><img src="/img/ask-response.png" alt="问答展示"></p><p>&emsp;&emsp;运用到的NLP知识：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3NDIyMjM1NA==&amp;action=getalbum&amp;album_id=1352624096995131393&amp;scene=173&amp;from_msgid=2649036142&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect博主的博客">https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3NDIyMjM1NA==&amp;action=getalbum&amp;album_id=1352624096995131393&amp;scene=173&amp;from_msgid=2649036142&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect博主的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计网与操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言处理 前后端 知识图谱 python技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git总结</title>
      <link href="/git%E4%BD%BF%E7%94%A8/"/>
      <url>/git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="git使用指南"><a href="#git使用指南" class="headerlink" title="git使用指南"></a>git使用指南</h1><p>无论是运行在哪个系统上，git指令都是基于linux指令的。</p><h2 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a>git常用指令</h2><p>git checkout — readme.txt<br>命令 git checkout —readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：<br>1.readme.txt自动修改后，还没有放到暂存区，使用指令撤销修改就回到和版本库一模一样的状态。<br>2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。<br>可以看到它和上条指令的区别，上调指令强行使工作区回到上一次commit的状态，而这条指令则是仅仅撤销工作区的内容，暂存区就更改不了<br>指令中的中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。  </p><p>rm readme.txt<br>该指令会删除readme.txt，不论readme.txt是否添加到暂存区。只要在文件夹中就可以删。删后要进行两个操作：1彻底删除，2将其恢复。注意：删除这个时间是发生在工作区的，如果我想彻底从版本库中删掉了此文件的话，可以再执行add,commit命令提交掉。只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？可以使用如下命令 git checkout — readme.txt  </p><p>新建dev分支，并将head指针移动到该分支上：<br>git checkout -b dev<br>这行指令相当于两条指令：git branch dev 查看并创造分支与 git checkout dev切换分支  </p><p>测试能不能连接到远程仓库：<br>ssh -T git@github.com<br><img src="/img/ssh-T.png" alt=""></p><p>git 查看当前git用户的用户名与邮箱<br>git config —global —list<br><img src="/img/gitbranchuser.png" alt=""></p><p>查看当前本地分支和远程分支的关联情况：<br>git branch -vv<br><img src="/img/gitbranchvv.png" alt=""></p><p>查看远程仓库的地址：<br>git remote -v<br><img src="/img/gitremote-v.png" alt=""></p><p>git查看当前树的结构：<br>gitk —all<br>观察所有分支构成的git树情况。<br>gitk<br>只查看当前的分支的</p><p>查看提交记录，并且提交记录中会记录下 本地仓库中标记的远程分支 和 本地当前commit的提交分支,图中本地分支领先远程仓库三个版本<br>git log —all   查看所有分支的提交记录<br>git log -<N> <branch_name>  查看单个分支的N次提交记录<br>git log —since=<start_date> —until=<end_date>   查看某个时间段的分支提交<br><img src="/img/gitlog.png" alt=""></p><p>当一条分支上完成git add .后，没有push到远端，而是选择切换到另一条分支上，这时就会提示你stash一下或者commit一下，而且commit的过程中如果没加-m，会报错如下图：<br><img src="/img/gitchangge.png" alt="">  </p><h2 id="git-合并"><a href="#git-合并" class="headerlink" title="git 合并"></a>git 合并</h2><h3 id="合并指令"><a href="#合并指令" class="headerlink" title="合并指令"></a>合并指令</h3><p>git merge <branchname><br>在哪个分支上（如dev）和并其他分支（master）,head指向这两个节点融合后的新节点，合并后dev指针指向生成的新内容但master还指向合成前的自己！想让两个指针均指向最新生成的节点就要在master分支上git merge dev。若和并的过程中有手动修改，导致master与dev,dev与master merge的结果不一样，则两个分支的指针不会都在master分支上，依然分别在两个分支上。   </p><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>用git status来查看冲突，直接打开冲突文件，查看冲突内容：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dddddddddddddddd</span><br><span class="line">=======</span><br><span class="line">切换至caogap分支，日后向master整合</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; caogap</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等线上下分别是两个分支的冲突内容，直接编辑该文件，删掉，保留得到目标文件，<br>git add . git commit就可以解决冲突了。<br>如果我不想合并了，该怎么办？<br>git merge —abort<br>前文中提到，如果执行git merge合并时发生冲突，则会进入合并的中间状态。合并的中间状态下将无法执行其他一些操作（如切换分支）。<br>如果不想继续合并，要先用git merge —abort命令退出。该命令会使你回到执行git merge 分支之前的状态</p><h2 id="git回滚"><a href="#git回滚" class="headerlink" title="git回滚"></a>git回滚</h2><h3 id="git回滚-reset-方式"><a href="#git回滚-reset-方式" class="headerlink" title="git回滚(reset)方式"></a>git回滚(reset)方式</h3><p>撤回命令：git reset HEAD^<br>可以看到，本地回滚成功，by 4commit变成了by 3commit，此时查看工作区，发现 被回滚版本 的内容还在工作区内，只不过从已提交状态变为了Modified状态（add .之前）。<br>但如果用：<br>git reset —hard HEAD^ 那么就不会撤回到 工作区修改 的状态，而是直接把工作区回退到上一次commit后的状态（上次commit-&gt;本次commit-&gt;工作区或暂存区被修改-&gt;reset指令），这是我们对reset指令期望的状态。这条指令执行后会让本地仓库中的head指针回退一次，同时清空暂存区、工作区中没有commit的全部内容。因此使用时一定要commit后再使用这条指令。<br><img src="/img/gitreset1.png" alt=""></p><p>git push -f origin master<br>本地回滚之后，强制push到远端，实现远端回滚，但要强制push，这样做对远端来说很危险！</p><h3 id="git回滚（reflog加jump方式）"><a href="#git回滚（reflog加jump方式）" class="headerlink" title="git回滚（reflog加jump方式）"></a>git回滚（reflog加jump方式）</h3><p>git reflog<br>该指令可以显示你的全部操作记录，每个操作记录都有唯一的一条操作码，比如你发现reset错了，想撤销所有reset回到reset之前的版本，只需要这样做：<br><img src="/img/gitreset3.png" alt=""></p><p>第一条指令跳到c8e2be9，这条指令是所有撤回操作前的最后一条指令，因此reset这条指令会回到这条指令执行结束后的状态，即从caogap跳转到master之后。此时查看status里都是干净的。</p><h3 id="git回滚（revert方式）"><a href="#git回滚（revert方式）" class="headerlink" title="git回滚（revert方式）"></a>git回滚（revert方式）</h3><h3 id="文件在暂存区与工作区的回滚"><a href="#文件在暂存区与工作区的回滚" class="headerlink" title="文件在暂存区与工作区的回滚"></a>文件在暂存区与工作区的回滚</h3><p>通过 git checkout — 文件名 命令可以撤销文件在工作区的修改。<br>通过 git reset 文件名 命令可以撤销指定文件的 git add 操作，将这个文件取出暂存区，然后把它放到工作区中。   </p>]]></content>
      
      
      <categories>
          
          <category> 软硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIOS启动！</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EBIOS/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EBIOS/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/472173336">https://zhuanlan.zhihu.com/p/472173336</a></p><p><a href="https://blog.csdn.net/wchstrife/article/details/78879554">https://blog.csdn.net/wchstrife/article/details/78879554</a></p><p><a href="https://blog.csdn.net/MoonWisher_liang/article/details/108408210">https://blog.csdn.net/MoonWisher_liang/article/details/108408210</a></p><p>bilibili</p>]]></content>
      
      
      <categories>
          
          <category> 软硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当生活回归正轨</title>
      <link href="/remake/"/>
      <url>/remake/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="19c21636a3bd3952c2dc443d6b5dddc5ea3e04d2e3c89f2bc66038ff0eb1b559">f743d48c94b6a11cf52081c3ff003ed0ef3c26deb9d0320ba8ab90c548f04333f7f40fa5c7ffa7b9aa7290de91eade91e746bdfe5d91fb374953671518e721dc22ae293bbb84d178b692137d688b13e6c902e2927b3dc71fb108440ff63c94e1d38fdc436e7e1314bbe9984d0e352cf8d2afdf29a1ca348f394333b24e97830beba808f1c855def4942b239599e1bbbfd7128046d1e594f228e2d067695e98ff14614a017c717ee94caf4f60513201bddf68feb8a686c584fe9515cf676e7bb561f460a9617a22746107dd03bc9b35625d9f38b16bbabd32a51df4f4a0a779a24e34dd91f0282ab37ce60dab8c74afdf77ffa435508144d0a18ffb797fc306a7fe49e5875471dfd034922de109fc4488868cd41720910b2dd41e7a9cb96066728b360d7e57a66adb086e31b997a9c934d1e87bac5af9912020098ca7cdbf3299470b27196a289bd4628c94cdc029fe43d11858e1a4a2f38b31a44d9fcb041bf498eb82eca8e2803fd8d05ec8ed39066ed3db1d28b233c58e22a7f87382d98af8ebda824746f874411b7f3351c465aae131e016d36a55c93a26379aaedda2d84ba8f6ba5f6909b028baf2eb1ed63b934bc16ba75e8d69eba68ad2efb3f2d491e72d1aa80d113783f223bdd34c170983ec7d052c61062ac86036a4278f731eeda141c5dc2d099fe9882589930fcd368b891b6a4a1b5094bf53fe64ace54010e335570cfbda9d19ac2b8f95d9fc18bb5ba723a5a03b1e06be2ffeec80ee245e411a117da8a3a7f0218f3bd0228f344bda39ab8c61017d94185165259d843b19a30d8bef8ebad1bf56e93701ec5e539c4a59e7477b430f39f074def6318d9c5d06b323deb00db82fdaee9a2151b1e5578327c0c0d951a596738f54fe00f287a85fc98f5bc25f4d70741112d8d96405a2341b69fbc6ed9c08bb8188fbbb347e4b1be9721b5ce3299666eb93ef7744f9dc7da17e5a927d71823a5892b29d62f64c93618b2890ca16f0381c21a6ba717f99fb1824c55b7b9bae16910d51c3bda21fd8789f07a1ec4c9774b7c679cf2e140d699dbec324851be6f91281c96a02aeb68bc8dc4b90d67544e77347710bd4cd610c412d2b6c5130756a06553efa674f83a6b4f4dec61bd33093e0098279f01e7dc5da3360102bd85972fd28fa8e2818a075b06e02385d347d2061545f3d912f8cc08bb2b523cf8ea1886a253ac1bd5f617a88440d6c88ea207097d48949cea8263778e3f247bf5d9742969405a97f5297f9438e7033e92f79a194a4b249c5835abd478008c01a08cc94390691da2749ad94799f5a222a422fcdb73707d3aabf991ecaa2f34249d7f235f55bd4465e3178ad499113ef748d439a7add29ee7cf7f1f69cef85c593f7f8eccec74d53ba09f48de519c70cada1a608deb36a388a9eef0f76168673a204f785d96bc00873db6b2554e7c53c464166898b4953d67cf0be7a72a42d46233f97052ac8916f90799eeed51df64fdc2a3e127f5bf8d75160c24a015aee475c9a12684d8c1decf852de490a32a59e3e0c8dff8e3cddca345e1768286755ba956a99e461ea5ebb827f807c2ff8cd4887126af681e104d0d9456a2e7865479a3217f481174e7a731643c4036004064675d729c00d30561972812b6433a218b8c238b656dd4a61d300acfe72a986178a9ea4df74d36ce7a801c455b96348ee9f05a7019aeb8b530f3f44b07a7a210f4f0edf5578e562996dad23f075cfb34c0f695aa5d44597b80d54c5138d2fd29f39b3b5676cddd89e4ce37efba89e8f8cc3e8a027853e0d7bd38a56a8ca956133a990061bb9129f5ccaebe52e20840fdc171d8ab30f1ab045e4c2b4562062d810aaea2aeb3bd7305686f163f8bef13b2227a1aca6ecf951e61ec785de1836edfaa4e05302032e4a2034abf28157f6135ab2d3692d13cd1c8b8607e7e4d074a88d86910e4385be67cb038ad8f0f16e7a1ea1eec8db342f3c41ce74b3f7a0645944f426ae4a024a72496bcd7a2aca74e1d25c7c8f736523c66673f67f26dfe1de5be9fb52bd2db1784fe519c378bab0c06e986d9fb049a8b8d4887f058b549340aee4352d750dfd13d6875ebfbf2aed2637f678485c8cf242132b4825b7cf9855b2c4962dd51168ada4991c0d349f2bd2d7c1f8b3ac657f017fda478d6ca87fd87262e622296b37f7ed2990874fc7642b8db8122aad8df849b0af39c7f17592f3aaf7096d8ce8302241ce75b7fe616b9a7e2c4e042d6e110fb0a557e63b13ac8e75a48e633186b88512b0ab810b8427779041be2574b2f2b99cbc54b7bee60a0da21e93f295fa56a3d6bd24d1eaf389d73e5b3da5f8335d9ff5bc60de73e1c4e33b399b9658d867d964ab9360d7b0a5388b26e31527a03fb8270fed3fe6663c773d5b9dd9b14253caf6d1dc23e5fc9d16ffe7d64917970f9682fde65dce4c8209b55139e18418830932a186b8f06b570c9d75a1719144e524bc405edd3d42668a8f4d670f8a55ae6c5e5383b4be2f8ab4f2e871182edb2900d33c4896870ddf193499870367c5fce3443fabaf4bdce99ffc5f1988051449407c2d4f8971b85d59ac2165e951449ef928bf9c3866a613e33a53ef89c413f3428bca0b40cdfdbcd883382bd62844e465601ac406a4779e0061a953166891f83a97b9ae7e8820c337353c66c766a7259d7f13fd8e52ae67b14c8aa3ee3f1dd3496cef6f5d5cf10f4312666db0fa8976c81c9f0bd67abe4b367dbf5f19a0cc56adfcd9e9049a0d2b888189a7a25ec6f99e5fa9c799f20e9ef34b5d6515ffed433d53585c11a58aa067c8a9d68d25c17ef8f9d2d1bfd39e9bd56190b42886945ab4443610271a82b866fa2646a07ac75a3cc51002050a46353f1c832197052f5aa04630e318ef36efd207d5639b6a69fd221579efe4fe38d1701d404155d1ee7a1ab9fc965ba4c615c49a291eeffb0e22d3b1c2a243fe33e3db9e9baaaf89e6bf84660c975fdfbd06cf6957aea46266e7baca85690ec5d99bce72dcbbbc69d9a53fad8d7551ed5129ed223c89468abe53f9cf8273305050c26a4a840db877a2ad07e907b13ffab9cc0a0c7fd46d63f53f9317d58a24ec0141f0c2318a271b3468e5f45d980fe56c86f99d080567d854201877c79265216c7357b4f2939cbd9d5502cff5c3e18746c4f0484859004a57249163541f9f10d7b2a13d2e39bf9fc52cf0f70c8b8867d111113706c156c5e89c307f349139a7632fb8f5488ce874dbde774b3856168dec02a52216a84a8a6d5f4f3662b4f6155e36e56bdedf97e5b081d12f6b32d12c40e120890564a49634549e8df68f5f4bba68bd960f1a0fc92a04c4765c825e02416036aeebed7d86843c40d53b90f2f96b7e00e0cdeed821d7afb8bebb89d63775d459fe6c92561000e3a4bd7d7fc5f1e080efd8b3a6d608a7140c3b56a9885147448b2f8bf19dfd6a5114059df7431b7cd104547c2847585e285d017b3f13820778e577e26aae6ee3543c366d97975ad176c7416b000469878ebabe0e23ccd57a58fda1de823d798e184333e559acdcb9f73dd1a12735b9cad38b51dd1d487a718813a901266d4215cdfc30cf153ccfd3d1abc2a1bd1d14a6bd95bb7e4a382f3a4fcb07de9f6e082e79092dd93ebec4316455225a7eaae46030009e5fdf47c2ef99e1c9a0d80885327d2b8ffe69684f316a5d04063cd4407d237260f6c2afff073271bb0ac687383dc109624616c219466e6557d77600b67f3063fdb62f27ccff64295b0f8a67b251f49825d9a0ff7a879e9761d4f13573c3553c1632ae36ce1070b22a2e4ccfb150056e1e774243efcb8bdf03b225b4fce83555a6b4eb6d656412467933caf83747e8d2cb925d40b3f1eea74ad5506d2ce2a0252f938c375fd917e1f83c35c88d61246ada40ce19c8e7d713c422af44967c7f0e66ba22c9e0b8e2f1cc74151ec5603aaa1c0836b403b2cd8a9ba13742c0d95f3317b1385c4c80a9605c977f50e8312876bea20d6e3cb78ce4abb4501b368bc2734921ad487cfac3b7f9efb8b277b799fd234b2c9c67dc0ca2d714b7b8b493a47c5761984e2fb1cba9567deca4690d27cd04cbcd734523829a025d86f6555eee086b0e4a7791d7af662c284cc0ed306c2ea8befde1de9bc0bc48819a1aa751501837c3d4d8b835065b23f5d8a35af14ced6cfed54e12a80b233a492373020bf07551c521584dabc1ecb4e36bdcd52bc9688279b1aa5216b18aec049b28df21b45b8b1359a46cde46aa7307de5e5d48d4912b7f0a51bfc918c8a6f568c5a10829d3bb304e38a83944082e63820167c7e5d6560ef5b886d87ff96d5cbc18e2f78fe7cbfaa90e9255dc9b348ae1cf510b53a63104d8dd6966b14fae91aab3dc4c1055365144dcd6cee390f5778e92bdca8291f0a4d53713c1110bdf0157d283ef9e4e92ae35503f374b401f372ff9de0da7370ffa0dc3346efe6cf0ffb2719939ccddaf6bdf28f53ff9a42784e76dd82246f3c48ea8a4057607d1d6ae93ccd56c21549388fe1c1b28e87b97f741e22bf6354f01059a55e16865ae8259dfc6b8b01af84908fbe87a57307beb76c4e6e69d4add6ce9c99e4a39cf5c150ac81edc0df8e9b61cf54701c7a9bb812602a73bf51b479d8f2686840aa2210971afdafc9110081fd4f6d4bbb249fed9231f7ce53f79a1cfa4c8db432a911f486c1db0d1562f3902cda6ed95bb9eaa7ec4093af5f55d6e9ddd95532bf3ade14bdcfc33a8628d723f08247f4ee5dc4a1298e2c3a470f3d49a7f11c88bc60b8fb00188057059d53ec6217f30f6e2309c6112788333f10be3cb9ea62f1e0982e65dd9f6a33e2a71eb9946141d8b90c2dc949011069d452c582790a4c10248754bd3c4a244de466311e77438b6878cdb4bfedeacbe0a57dd927503650a3b3948f6d0d5095161a1cb93ca3e8850d4455364e54863454bd39090739476b1b7491e1fd081e587e570e641f0e171a7b81fce165d3fe4f5b0ff891719d36a303737500ae023c5600bac5a51f9d54fd6a86a254012b88ef760fa7d5ad57d7bfde89024d37ec2415c6b8813b6fda1f429c233d16a3cfeef624f28129085f2a9f62d0aefd7c66da19245e1e49e772dd8120474f7fedfdb24fb79afb21acbf6ad8db5e931a2567a7cc0f40aec839edc4a4b97ca69086c01292b8881e41db4ee6c240c9bcbe009ff98e801c82c08d9c6b40ce967b19007643c124be3e3f9527e844880fefd5bf7a6e01d34d60f967af0d0a0b51389ce67f5642c17e7dcb10eee4dd63a2209e558bab809624680d299c215cbb7b04c343a7f22216acf500c5139d2e35a05930039fe38fc51afa7de1cfd98603956f0e961f6f8fd736d7a4b8d98fb260825d3efb9b6f0bff8ec1fa708066e913acd75d4a8be2215eb667b3895d4f07d891ba082e9b9811ba975e637b01da6fe81b0eb4eafe301797f5242cb28cacd51b515a2d0a859195fdd2947e2f0daadf5ff514503560357455612a47c8af652437cf5e91afccbb74ae669a6457fe81793c31b427d4c5c015809c40953b4892892da2f74be42907ac909308c8c341df00b4aa801193758342755b3a3c15021c15652630428dbc1e7ad0e0d303cf125a62e48eebc1a991fa7b404dd779da12ead96dac18854696caaa73ee341c2a5d8405893a0234052931d408c00ab375f980871b6676d7d540a75ed892f07d1df8536579382c417b57defaaa9c66d45d9954f9654a36df6cf0241b73bbff17ee1ace36eab3241b2af3903d23156f70692178ba06cac8a40af53e66c928989e9f64eff2ec15562cd9baba474342b5bb3f8415d3ad330df7a2f1d70f929177441e4419dcce4f7ccbf15cdec3d8b823c60f5965d8f8aa207ff8cf0746ce0eef0bb60879f3c87958d9543c4be21d944606bd6c45ab69eb9b0bc8a8b08ec629a9cdd72ec2851926e9c480309ab1b64d72c7111f5cea759afb4684f1c69c3d3c704901137a6858792843044ab77633577570d920e3b925135a37fed6c3086011ed88847ec5cf5ec4ca007a18b832e426b41cf6beedc4b82e1b9155e4d09819ededa79074ecdb15da088c70fe7b7ffa39b4ba9506847b2c1d376e7bfa3148bf8342d5dc7c7dab7fef3d4f1b55fea3888eee2c84dcf40d19339b75c23439b0e2b7ddbd9d38d34b3ab7358ae7c1b9ccbc0e0c2ee5f9b69ce9b34bd2d73a5c936d2344784af20b70b5f4ed7ccc1a9bed8502ae8ca0cd7af170f2fe7db47d1dc80d67d4e2631bff437e35463421e8ff032b6c48907e8bb45a93473dd1150a2ade1f285458a9e1d9bac186861fa2ac0fab346a3b92b80c9aea91c6386a948e15f0008e4b30e6fd2bd074ff883218ab658f85c411f46d6085b9033170d07e17db7da6853f6c1fe2e501df7f45298868704bba9240f2bc43e22eacb7f5e2a4e8c143f6dc80da55006285a8fc970eda5c46b4ce47e73154b0676b8cb0830ce66b28273c978660fe11d67a2f166abf0e19082ea49b53b7647cccbde4ea2af3115fc84e8639943937e9f199326f3950ad0879a2baf8136d02d451552cf35248759f2cfd3baf280f5f09e2ba4e070f59cc7424b62655d15813a18543312a37197ec7741714b27a8b982453e227d179fc0a81fbfce001721afeb16c76745e2febc266975b128a0f3670fb50d775097b7dae5a8fd3d510ed06dccb7a64cc4663f8b9cd71f2489436bccb8bbffaa0a796fb8fb2ffb1a16e1802542aa976564fdae1e5514d7b6ac67ac2c96087f2ca93cb5e9576455b585a541c3579b4e5a7f3c4dcab5c4b67bf016cc9ce2a39faac36f539dff039764361b5a4fd4bb743ff33be0819b0cbd6a59b8eee570542e79706307da0c2813bb673076cc73635ebb7acf5bcb242b3567de2571da6dd6747844de2fc0136e732711b1077f0b4a8fafb5590cfe276b01a7b8781d5cfca73e9b48029c25797762e99e222f82de0f8ff125cd9f02696ae5a1da067e9924f72fbb56d584388c04ff5a66a26a8eb0f53181f637f7d496aea7bca15ca2eb4e2862f41af3351c0a79d083a97edaca52579c97489ed7cbd3fea4283baf3aa63bfb7a9f34c926c358992e9a8e95e9b5cd5cf08910cf9bded0598c9883eec44a82f4a530760c636c22578392bbfa8f42f9c047bad5f74fa3b5f94881a8fe27b9fce307f7d7f48ee8f213740ef272fa5fdba67d68d8c8dd1cb6f21d234c92bcedf01b47479fbea83a0bdd2dce32c45baa3544cdbac5ca4f0f8af293e2efe6d992d6e38089c117b3d1dd08552ac04495cb8b72215517d7d8246677ce45f44aeffe92366963c8dc61d81ed325b28ae18784d43c800b60e6d5245291432175feed38f5e5a0854b0ceb49d71919d2ab21aaae43d1f0293e5dc9962ffb168586ead1ad55f46be17862925059d70ee87c62e0be8d195b55798638179bb2723161f6944cc73e760976a01532ef88cc2fe69dfd2b8b4efbe347a7a88ea0eebdb6f9e673a8681d6e30892df919c28cffbf6e446b0f73daf6f4d90dfeecfafbd6e90d95819f8d4136cae2d67fe821d05989def8ae6c975e722bcfc22618fa964dedf20ed3e5eba74d9999f1aa681d8b0b596494a79b8c8c9366933231cb64d78c81592494de015d5540b9b7e1fdcdd1af5dbf865c291b834f0e7738966564c94013d2ab3d08dcb837b457d522eee3f2d67a883d92bb51eab87a23eb577d1436b0b44cc0c46369171f599685e56cfdeacbe63ca99e4a6bcaea227fd9032931f31601c86e44ddb71b92ea1ea106b5cdbca2e57d93a28b5bf9600d29d81cf6088ec94059ad2bf8c89dac199b822d50500c47783f2a5fa4d306ff5650799b2d1b3dbef5a3cdbae5f8333edcf24703b4e1524cf0ed01b3856ecde101200a5b4702b3cd27c8af69c8450c6e1883168c292fbd7c93062cc3bcad71531c890a057a2d2a843ac55035f24070a15de15bf10e07bc05c2ab5241adca87ebc6d49a8f4f89a1036e0a3f8833cd78073f46809a3cdd6e998d797844593b206ae4d48c9764f82604ae2dec7690f692a79dc83c7eaedb0336c57ecbb2b313e8cd4a3fd272523072abc582bb328a3d258d8523def2366a26106dc5a4a01aa47e7054c613f7b47fd888b4c24fdb35bdfa414bb037dc927cd0c6bbf8025003e625554be70695b55f57759b034855190b6d7f19cce52233cd96091b96a256d0a7b1769c07af9991f3d690e1b2f7fdd9f572a41a8a6204a2990e16d7443c9fcec60dca1c7b8a56a547bacb5ffeddefc4b71297dea95289912d5715eb2d2f802aed24158ed89b213b50d88638fdcaa02368b36c3b4828094feb26927762adaf2681bc9b4d2a714a7d8132ae2b3e00a066019ef6df09937b8edc1991754d2e2487df84a918e0af4f36cc23262fc6b93d9f11de0f08652e38f499ad253932b2311136111cc077992aa8a57e9c1a95e35db39e793ba944099428397f480ee133bba67f51c15d3a3dc9b114dac203a4e575084c4b118ff7129d7923ffc0b1ba12457a57c5336c5b16720209e1dae9351f00786d29776f119c699346924fd3708b65a822a986d08bce7f3313fb72acdd2f885d7415b299fa624ac942e8e49b3b30e95c865080a09ff0a95c59ef4a1d125c0bfac9424809bdd449</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C++ QT中的Tcp</title>
      <link href="/Tcp/"/>
      <url>/Tcp/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/fox.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><p>&emsp;&emsp;<br>套接字定义：应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字 (Socket)的接口（函数库），区分并实现不同应用程序进程间的网络通信和连接。<br>&emsp;&emsp;其实Socket就是一个大类，实例化两个实例，调用里面的函数就能实现通信。</p><p>&emsp;&emsp;套接字其实就是函数的接口，需要三个参数：通讯类型（Tcp，Udp），IP，端口号。Socket原意是“插座”。通过将这3个参数结合起来，与一个“插座”Socket绑定，应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。<br>&emsp;&emsp;要通过互联网进行通信，至少需要一对套接字，一个运行于客户机端，称之为ClientSocket，另一个运行于服务器端，称之为serverSocket。</p><p><img src="/img/79tcp.png" alt="TCP通信流程图"><br>步骤一：把这两个套接字实例化<br>&emsp;&emsp;这两类套接字都有自己对应的代码库，实例化就行。</p><p>步骤二：连接两个套接字<br>&emsp;&emsp;根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为两个小步骤：1服务器套接字设置为监听，2给客户端套接字指向服务器IP与端口，并连接。<br>&emsp;&emsp;1：服务器监听过程：服务器端套接字并不定位具体的客户端套接字，也就是说并不需要客户端的IP与端口号（只需要记录说话的内容而不需要记录说话的是谁），但是要在listen函数中绑定自己的网卡对应IP与端口用于监听。这时处于等待连接的状态，实时监控网络状态。<br>tcpServer-&gt;listen(QHostAddress::Any,8888);<br>这表示服务器套接字tcpServer监听自己网卡对应的所有的IP地址以及IP地址对应的8888端口。<br>&emsp;&emsp;2：连接：是指由客户端的套接字提出连接请求（方向固定！一般都是默认客户端请求服务器），要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>tcpSocket-&gt;connectToHost(QHostAddress(ip),port);<br>代码含义：客户端套接字tcpSocket绑定服务器的IP以及端口号，也就是上面服务器监听的端口号。QT中的ConnectHost函数可以为客户端套接字连接服务器套接字</p><p>步骤三：确认连接<br>&emsp;&emsp;服务器端，如果接到客户端的套接字传来的连接信息，会发出newConnection()信号。<br>listen到了，connect(tcpServer,&amp;QTcpServer::newConnection,<a href="">=</a>{qDebug&lt;&lt;“收到客户端的连接信息”});<br>&emsp;&emsp;之后服务器的套接字会向客户端套接字发送已连接信息(也是系统自己操做的，实际是tcpServer生成的tcpSocket发送)，客户端收到该信息后会产生一个connected()信号。<br>connect(tcpSocket, &amp;QTcpSocket::connected,<a href="">=</a>{ui-&gt;textread-&gt;setText(“成功建立连接”);});<br>&emsp;&emsp;连接成功后，tcpServer套接字会获得请求通信的套接字tcpSocket的IP与地址，以备回复信息使用。<br>查看ip与端口的代码：<br>QString ip= tcpSocket-&gt;peerAddress().toString();<br>qint64 port= tcpSocket-&gt;peerPort();</p><p>步骤四： 发送信息<br>&emsp;&emsp;套接字连接成功后，两个套接字之间就仿佛建立了通道，可以相互发送数据了！但需要注意的是：<br>1：信息从通道一端发出就必定会传播到另一端，就好比你打电话一方说一句话声音必然也只能传达到另一方，因此发信息的过程不需要再人为指定对方的IP与端口(通道建立的时候双方套接字内已经指定了对方套接字的IP，端口信息)，你只需要调用tcpSocket-&gt;write(str.toUtf8().data());就可以发消息了。<br>2：tcpServer是监听套接字，也就是说服务器套接字只能监听端口，这就意味着服务器不能收发消息！怎么办呢？再在服务器端创造一个tcpSocket套接字呗。但再创造一个套接字的话就意味着上面的所有和客户端套接字的连接步骤还要重新来一遍，还要创立一条新通道，麻烦！如何用之前我们已经创造的通道给客户端通信呢？QT C++的库中已经给我们写好了按原通道回话的简便方法，依然使用连接好的通路，在服务器端的代码中：<br>tcpSocket = tcpServer-&gt;nextPendingConnection();就是在tcpServer的基础上生成一个tcpSocket。<br>&emsp;&emsp;注意，这个tcpSocket是服务器端的第二个套接字，但与重新实例化一个套接字不同，由于它是在tcpServer的基础上生成一个tcpSocket，它知道通道另一端的客户端套接字的IP与端口，因此可以直接回复信息（客户端的tcpSocket连接服务器的tcpServer，服务器端的TcpServer套接字生成了一个子套接字tcpSocket，由这个子套接字tcpSocket和客户端进行收发消息通信）。</p><p>至此，大功告成，实现了客户端和服务器的双向通信。通完信不要忘了断开客户端连接，关闭套接字<br>我们需要明确的是：1、接受信息的一方不需要发送者的IP与port,发送信息的一方必须要知道对方的IP与port。<br>                2、tcpServer只有监听功能，服务器的收发信息功能是由它生成的tcpSocket负责的。</p><p>客户端cpp代码：</p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;clientwidget.h&quot;</span></span><br><span class="line">#include <span class="string">&quot;ui_clientwidget.h&quot;</span></span><br><span class="line">#include &lt;QHostAddress&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">ClientWidget</span>::ClientWidget(QWidget *<span class="built_in">parent</span>) :</span><br><span class="line">    QWidget(<span class="built_in">parent</span>),</span><br><span class="line">    ui(<span class="keyword">new</span> <span class="attribute">Ui</span>::ClientWidget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    tcpSocket = NULL;</span><br><span class="line">    tcpSocket = <span class="keyword">new</span> QTcpSocket(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    connect(tcpSocket, &amp;<span class="attribute">QTcpSocket</span>::connected,</span><br><span class="line">            [=]()</span><br><span class="line">            &#123;</span><br><span class="line">                ui-&gt;textread-&gt;setText(<span class="string">&quot;成功建立连接&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    connect(tcpSocket, &amp;<span class="attribute">QTcpSocket</span>::readyRead,</span><br><span class="line">            [=]()</span><br><span class="line">            &#123;</span><br><span class="line">                QByteArray array = tcpSocket-&gt;readAll();</span><br><span class="line">                ui-&gt;textread-&gt;append(array);</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">ClientWidget</span>::~ClientWidget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">ClientWidget</span>::on_Buttonconnect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString ip = ui-&gt;lineEditIP-&gt;text();</span><br><span class="line">    qint16 port = ui-&gt;lineEditport-&gt;text().toInt();</span><br><span class="line">    tcpSocket-&gt;connectToHost(QHostAddress(ip),port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">ClientWidget</span>::on_ButtonSend_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString str =ui-&gt;textBwrite-&gt;toPlainText();</span><br><span class="line">    tcpSocket-&gt;write(str.toUtf8().data());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">ClientWidget</span>::on_ButtonClose_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(NULL == tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tcpSocket-&gt;disconnectFromHost();</span><br><span class="line"></span><br><span class="line">    tcpSocket = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器.cpp代码<br><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;widget.h&quot;</span></span><br><span class="line">#include <span class="string">&quot;ui_widget.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Widget</span>::Widget(QWidget *<span class="built_in">parent</span>)</span><br><span class="line">    : QWidget(<span class="built_in">parent</span>)</span><br><span class="line">    , ui(<span class="keyword">new</span> <span class="attribute">Ui</span>::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    tcpServer = NULL;</span><br><span class="line">    tcpSocket = NULL;</span><br><span class="line"></span><br><span class="line">    tcpServer = <span class="keyword">new</span> QTcpServer(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    tcpServer-&gt;listen(<span class="attribute">QHostAddress</span>::Any,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    setWindowTitle(<span class="string">&quot;服务器： 8888&quot;</span>);</span><br><span class="line"></span><br><span class="line">    connect(tcpServer,&amp;<span class="attribute">QTcpServer</span>::newConnection,</span><br><span class="line">            [=]()</span><br><span class="line">            &#123;</span><br><span class="line">                tcpSocket = tcpServer-&gt;nextPendingConnection();</span><br><span class="line">                QString ip= tcpSocket-&gt;peerAddress().toString();</span><br><span class="line">                qint64 port= tcpSocket-&gt;peerPort();</span><br><span class="line"></span><br><span class="line">                QString temp= QString(<span class="string">&quot;[%1:%2]:成功连接&quot;</span>).arg(ip).arg(port);</span><br><span class="line">                ui-&gt;textread-&gt;setText(temp);</span><br><span class="line"></span><br><span class="line">                connect(tcpSocket, &amp;<span class="attribute">QTcpSocket</span>::readyRead,</span><br><span class="line">                        [=]()</span><br><span class="line">                        &#123;</span><br><span class="line">                            QByteArray array = tcpSocket-&gt;readAll();</span><br><span class="line">                            ui-&gt;textread-&gt;append(array);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        );</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">Widget</span>::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">Widget</span>::on_Buttonsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(NULL == tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QString str =ui-&gt;textwrite-&gt;toPlainText();</span><br><span class="line">    tcpSocket-&gt;write(str.toUtf8().data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">Widget</span>::on_Buttonclose_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(NULL == tcpSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tcpSocket-&gt;disconnectFromHost();</span><br><span class="line">    tcpSocket-&gt;close();</span><br><span class="line">    tcpSocket = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>至于Tcp粘包处理，可以在接收函数中修改，详见下面视频。<br><a href="https://www.bilibili.com/video/BV1yf4y1Y7CU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1yf4y1Y7CU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p><p>TCP三次握手：<br>&emsp;&emsp;TCP协议是传输层里面的一个协议，TCP在建立连接之前进行的三次握手对于很多人来说可能一直是迷。干嘛要握三次手？握其他次数不行咩？<br>那么我们就来讲讲TCP的三次握手都干了些什么吧（才疏学浅，说错的地方希望大家指正）<br><img src="/img/three.png" alt="TCP三次握手"><br>一、首先要明确三次握手的目的是什么？<br>三次握手的目的是为了确认客户端和服务端的收发功能是正常的。</p><p>那么就是需确认的东西一共有4个：<br>&emsp;&emsp;1.客户端的发送功能；<br>&emsp;&emsp;2.客户端的接收功能；<br>&emsp;&emsp;3.服务端的发送功能；<br>&emsp;&emsp;4.服务端的接收功能；</p><p>二、那三次握手分别都确认了哪些功能呢？<br>1、第一次握手<br>&emsp;&emsp;第一次握手是客户端主动发起的，简单粗暴的理解就是客户端给服务端写了一封信；<br>&emsp;&emsp;这就跟以前的人寄信一样，我自己知道自己是把信放进了邮箱里面，但是我并不知道邮差是不是把它拿出来寄出去了，<br>&emsp;&emsp;也就是说，客户端只知道自己发送了报文，但是报文有没有被发送出去就不知道，所以这个时候客户端对于自己的发送功能是否完好是不确定的；<br>&emsp;&emsp;但是当第一次握手的报文被送达服务端的时候，服务端就知道自己的接收功能是完好的了；因为它已经收到了嘛；<br>&emsp;&emsp;所以第一次握手就确定服务端的接收功能（括号内为握手编号）：<br><img src="/img/first.png" alt="第一次握手验证的功能"><br>注意：你可能会说，服务端收到客户端的信了，看到信了不就可以知道客户端的发送功能是完好的了吗？很遗憾，我们要让客户端知道 自己 的发送功能和接收功能是正常的；要让服务端知道 自己 的发送和接收功能是正常的，这也是为什么客户端发送一个seq=x,服务端要回信一个ack=x+1，这就是第二次握手时告诉客户端你发送的具体内容我可以收到，因为我回的是你发内容+1！这样客户端在第二次握手就知道自己的发送功能正常了！</p><p>2.第二次握手<br>第一次握手是客户端发起的，第二次握手就是服务器端发起的；<br>别人给你写了信，你收到了肯定就要回信嘛；<br>那么这个时候我们就可以来看一下参数（为了方便理解，我们暂时将报文信息理解成参数）：<br>第一次握手客户端会给服务端传过去两个参数，其中有一个是：seq=x;<br>SYN我们先不管，这个seq=x我们就可以看成是写在信里的内容；<br>第二次握手的时候服务器端给客户端返回的是4个参数，其中有2个是：seq=y;ack=x+1<br>那么这个ack=x+1我们就可以理解成是回答了客户端写在信里的内容，因为来信是x，客户端接收到来自服务端的x+1的时候就知道自己写出去的东西被收到了；就可以知道自己的发送功能的正常的；同时客户端也能知道自己的接收功能是正常的，因为能够接收来自服务器端的消息；<br>那为什么服务端也要写出信息seq=x给客户端呢？<br>因为服务端也不知道自己的发送功能是否正确嘛；<br>所以在第二次握手里面可以确定的功能是：<br><img src="/img/second.png" alt="第二次握手验证的功能"></p><p>3.第三次握手<br>第三次握手是客户端发起的，就是这么一来一回的；<br>在第二次握手里面我们就知道握手和确认功能完善之间的逻辑，那么接下来也只剩下一个功能，就是服务端的接收功能；<br>服务端怎么知道自己的发送功能是正确的呢？<br>类比第二次握手我们就知道了，只要收到客户端关于seq的回答就好了；<br>第二次握手的时候服务向客户端发送了seq=y<br>有seq发出去，那么客户端就要将对信的回复写在ack里面；<br>所以第三次握手所传的参数里面有ack=y+1，也就是说客户端回复了服务端的seq;<br>当服务端接收到这个反馈的时候就知道自己的发送功能的正确的了。<br><img src="/img/third.png" alt="第三次握手验证的功能"></p><p>总之呢就是一句话：能接收就说明接收功能正常；但是能发送不一定代表发送功能正常，发送功能需要通过 seq(写信)和ack(回信) 才能判断。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中的UDP、TCP比较</title>
      <link href="/UDP/"/>
      <url>/UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><font color=LightSeaGreen>步骤</font></h1><p>&emsp;&emsp;1：实例化两个套接字(服务器和客户端的套接字都一样，不用再向TCP一样分serveSocket,TcpSocket)<br>&emsp;&emsp;2：接收方bind() 自己的端口port，IP<br>&emsp;&emsp;3：收发<br>&emsp;&emsp;4：关闭套接字。</p><h1 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a><font color=LightSeaGreen>TCP与UDP区别</font></h1><p>&emsp;&emsp;UDP通信过程中，每次都需要指定数据接收端的IP和端口，和发快递差不多，每次发都要填地址；<br>TCP则三次握手建立通道后每次发送就不必指定端口和IP了，在通道中就发送了。;和打电话一样，电话一旦接通就随便唠了。<br>UDP：</p><pre><code>udpSocket-&gt;writeDatagram(str.toUtf8(),QHostAddress(ip),port);</code></pre><p>TCP：</p><pre><code>tcpSocket-&gt;write(str.toUtf8().data())</code></pre><p>从两者的发送可以看出UDP每次发送都要填IP与Port，TCP建立完通道后就不用管了。</p><p>&emsp;&emsp;UDP通信不需要建立连接，因此不需要进行 connect() 操作。TCP则又是newconnection 又是connected来确保连接畅通。</p><p>&emsp;&emsp;TCP是以字节流的形式传输数据，因此会出现粘包现象，UDP则以数据包的形式传输。</p><p>&emsp;&emsp;使用UDP进行通信，服务器和客户端的处理步骤比TCP要简单很多，并且两端是对等的(通信的处理流程几乎是一样的)，也就是说并没有严格意义上的客户端和服务器端。但哪一端是接收数据的角色，那么这个接收端就必须绑定（bind）一个固定的端口，因为起码得告诉发数据的人往哪里发吧。如果某一端不需要接收数据，这个绑定操作就可以省略不写了，通信的套接字会自动绑定一个随机端口，并且随着数据发送过去，在接收端recv()函数中会解析出发送者的IP与Port，这样接收者也能给发送者回话了！这点和TCP差不多。不过这种只绑定一端的做法的代价是，绑定方无法给未绑定方发消息，因为绑定方是不知道未绑定方的IP与Port的（未绑定系统随机非配发送端口），也就是说第一次发送的方向是固定的！这点和TCP一样，用TCP协议也基本上默认了第一次发送方向固定这一条件。怎么实现向QQ一样两边谁先发都可以的通信呢？两边都bind()就可以了啊！这样两边的发送地址都固定了，都知道对方的IP，port的情况下，谁先发都可以。</p><p>&emsp;&emsp;TCP是一定会完整，准确的发送数据的，粘包可以自己解决！UDP不对收到的数据进行排序，在UDP报文的首部中并没有关于数据顺序的信息，UDP对接收到的数据报不回复确认信息，发送端不知道数据是否被正确接收，也不会重发数据。如果发生了数据丢失，不存在丢一半的情况，如果丢当前这个数据包就全部丢失了。因此，UDP简单，随意的代价就是可能会数据丢失。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><font color=LightSeaGreen>代码</font></h1><p>附上UDP.cpp代码，客户端和服务器共用一个代码，都bind()了：</p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;client.h&quot;</span></span><br><span class="line">#include <span class="string">&quot;ui_client.h&quot;</span></span><br><span class="line">#include &lt;QHostAddress&gt;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client</span>::client(QWidget *<span class="built_in">parent</span>) :</span><br><span class="line">    QWidget(<span class="built_in">parent</span>),</span><br><span class="line">    ui(<span class="keyword">new</span> <span class="attribute">Ui</span>::client)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    udpSocket = <span class="keyword">new</span> QUdpSocket(<span class="keyword">this</span>);</span><br><span class="line">    udpSocket-&gt;bind(<span class="number">8887</span>);</span><br><span class="line">    setWindowTitle(<span class="string">&quot;端口8887&quot;</span>);</span><br><span class="line">    connect(udpSocket,&amp;<span class="attribute">QUdpSocket</span>::readyRead,<span class="keyword">this</span>,&amp;<span class="attribute">client</span>::dealMsg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client</span>::~client()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">client</span>::dealMsg()</span><br><span class="line">&#123;</span><br><span class="line">    char buf[ <span class="number">1024</span> ]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    QHostAddress cliAddr;</span><br><span class="line">    quint16 port;</span><br><span class="line">    qint64 len =udpSocket-&gt;readDatagram(buf, sizeof(buf),&amp;cliAddr, &amp;port);</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QString str = QString(<span class="string">&quot;&#123;%1:%2&#125; %3&quot;</span>)</span><br><span class="line">                .arg(cliAddr.toString())</span><br><span class="line">                .arg(port)</span><br><span class="line">                .arg(buf);</span><br><span class="line">        ui-&gt;textEdit-&gt;setText(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="attribute">client</span>::on_Buttonsend_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QString ip = ui-&gt;lineIP-&gt;text();</span><br><span class="line">    qint16 port = ui-&gt;lineport-&gt;text().toInt();</span><br><span class="line">    QString str =ui-&gt;textEdit-&gt;toPlainText();</span><br><span class="line">    udpSocket-&gt;writeDatagram(str.toUtf8(),QHostAddress(ip),port);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创作一篇博客？</title>
      <link href="/%E5%A6%82%E4%BD%95%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E5%A6%82%E4%BD%95%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/22.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><p>用Hexo，butterfly主题搭建博客<br>&emsp;&emsp;相信大家有时候会产生给自己造一个精致的所属空间的冲动吧，在我看到了别人优秀的博客后我就下定决心要给自己做一个精致的博客，想想只要在浏览器中搜索 <a href="https://yhl2333.github.io">https://yhl2333.github.io</a> (目前域名，正在向www.heluYang.com努力奋斗) 那全世界人都能搜索到我的网站，这个网页就是我的。</p><p>&emsp;&emsp;那么怎样创建一个博客呢，在本文中我会详细列出我的制作流程，而且大家也不必担心有一些网络技术不会导致半途而废。别急，请先大致浏览一下全文再动手搭建也不迟。</p><p>大致工作流程可以分为三部分：<br>1: 在本地新建文件夹用在有的hexo主题下修改成自己喜欢的样式（编译器用的VScode）;<br>2: 将做好的博客的文件夹通过git上传到github仓库。<br>3：在github仓库中将文件夹内容Page一下生成静态文件，这样就可以被其他人通过输入网址(如https:/xxxxxx.github.io)查询到了（百度除外，建议用非百度引擎搜索）。<br>4：通过购买腾讯，阿里服务器可以将博客部署到他们的服务器上，并绑定买好的域名（如www.xxxxxxx.com），这样就可以很快速的访问了（此步有需求的人可以用，没有需求大可不看这一条，到上一步一样可以搭建）。<br>以上步骤大可以无脑进行，99%的人的选择。</p><p>下面是几个要点，需要了解：<br>1：会翻墙（也就是会魔法），没有魔法你甚至连github,git都碰不了，至于git，github，魔法，请翻看我的软硬件杂谈，里面有详细的说明。<br>2：github与git的使用，这是俩东西，本次搭建过程中可以理解为一个发送一个接收，这个跟着视频流程走就可以了，不需要去学到底咋用的，但要先在github上注册账号，而git是一款单独的软件要下载，这俩教程也是网上烂大街的。如果你会魔法的话，这俩的安装和注册真就有手就行。</p><p>&emsp;&emsp;好了，以上几点满足的话我们就可以开始了！</p><p>做博客的平台选择：<br>&emsp;&emsp;首先要弄清楚的一点是要搭建静态博客还是动态博客，本博客就是静态博客，动态博客我相信普通人是用不到的，它与前者的主要区别就是它是服务器的数据库实时发送数据来维持的，而静态博客完全是服务器发来的一个.html页面。写博客，留言等静态博客完全够用了，还有最重要一点就是静态博客不要钱，动态博客有成本，而且还是和优酷续费的那种，你说你创建那种博客？必然静态。你看到的wordpress等属于是和hexo并列同功能的，但是是搭建动态博客的，收费。</p><p>做博客的软件：<br>&emsp;&emsp;我可以告诉大家静态博客的制作完全可以无脑选择Hexo ，大多数人都是这么选的，上面提到的butterfly主题是什么呢，你就理解为博客网页是手机界面，是Hexo的附属包，butterfly，next等主题就相当于是手机的不同主题。这些软件怎么下？下什么版本？看下面链接，我就是按下面视频做的，适用于任何windows10以上的系统，视频中有详细操作步骤。<br><a href="https://www.bilibili.com/video/BV1mU4y1j72n/?spm_id_from=333.880.my_history.page.click&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1mU4y1j72n/?spm_id_from=333.880.my_history.page.click&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p><p>博客界面设计：<br>&emsp;&emsp;当你学习完以上的视频并操作后，你会有一个Hexo默认的博客界面，并且已经上传到github中以便以后发推文实时在github中更新，此时你想的一定是想要美化界面，想要更好看的界面，这类视频在b站上都不太好找，下面是我找到的，紧接下文：<br><a href="https://www.bilibili.com/video/BV1sK411Q7S7/?spm_id_from=333.999.0.0&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1sK411Q7S7/?spm_id_from=333.999.0.0&amp;vd_source=b6da26061de3320a8170666f06381a91</a><br>去这个up的视频库里去找，有可以做成这种效果的完整系列视频。</p><p>如何去写博文：<br>&emsp;&emsp;这里才是你做博客的核心目的！写文章，但写博客和写记事本写word是两回事，得学，下面是up的视频：<br><a href="https://www.bilibili.com/video/BV1uW411G7nP/?spm_id_from=333.880.my_history.page.click&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1uW411G7nP/?spm_id_from=333.880.my_history.page.click&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p><p>如果你做完这些，那么你已经达到或者超越了我的博客网站的水平，接下来我会说说你可能会产生的问题：</p><p>问题一：做博客不是免费吗，到底要不要花钱呢？<br>answer：首先，做博客，将其上传到网上，能够被其他人打开，这个过程完全是免费的，但这时，你的博客域名是<a href="https://xxxx.github.io">https://xxxx.github.io</a> ，发现问题了吗？，就是github，github在整个过程中的作用相当于它充当了服务器的角色，任何人想要访问你的博客网站时，请求被发送到DNS进行域名解析，发现你的博客网站是存在github服务器的！而github服务器在国外，访问，将网站内容发送给访问者极其困难，慢，要挂外网的，挂外网也不会很快，你的界面设计的很复杂是要好久才能加载出所有内容，因此，开始氪金，你会问有没有不用钱的？我的回答是绝大部分人都自己去阿里云，腾讯云去买服务器和域名了，你自己细品。gitee和coding我都试过，coding与腾讯联手在朝着氪金方向发展，而Gitee则受到了国家的监管，你上传的内容在部署到服务器上时会被审核，发现有违规内容也不会告诉你哪里出了问题，而且都是国内仿照github做的仿版。有了自己的服务器和域名，相当于把你的博客数据从github服务器转移到我们自己的WLAN就可以直接访问的阿里云，腾讯云服务器了，而且这些服务器都有CDN加速，自然就可以快速加载快速打开了，但是服务器加域名费用的话差不多一年150左右，也有学生价，当然如果不想展示给别人看（不是不能，是加载慢）只想自己看自己写的话就可以停留在<a href="https://xxxx.github.io">https://xxxx.github.io</a> 了。</p><p>问题二：为什么有的插件，包容易下载不下来，有的会警告有错？<br>answer: 建议外网和内网切换尝试下载，下载时以管理员身份运行GitBash，后VSCode；有的包下载完会报错，提示 git audit fix,但其实这是包的版本问题，想处理就按照他说的 git audit fix，不想处理或处理不了就跳过，依然能用。</p><p>问题三：如何解决数据做好的博客页面加载慢的问题呢？<br>answer：氪金，买服务器和域名，而且要备案的，不算简单；也可以把里面用到的图片存成HTML文件到达图片更快加载的效果，或者把特效关了，不过这两种解决不了根本问题。</p><p>问题四： 如果博客/网页里放了很多图片，打开网页的时候会加载很慢，那应该如何解决呢？请去看 CDN、文件传输“图床”篇。</p><p>大致就是这些，吃晚饭去</p><p><font color=orange size=4 face="黑体">Markdown字体颜色，高亮</font><br><a href="https://blog.csdn.net/Treasure99/article/details/105601866">https://blog.csdn.net/Treasure99/article/details/105601866</a></p><p><font color=orange size=4 face="黑体">代码段</font><br>代码段前面必须空一行，全选按tab</p>]]></content>
      
      
      <categories>
          
          <category> 软硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于网络的认知</title>
      <link href="/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我们每天都在登录B站，每天都在科学用网，只要手动输入 <a href="https://www.bilibili.com">https://www.bilibili.com</a>  我们就可以进入b站了，但你有想过这件事是如何实现的吗？还有当我们在做客户端，服务器相互传输信息的时候，IP和端口是干什么用的？在这篇文章中我将详细对标签中的各种名词做出解释。</p><p>&emsp;&emsp;首先，从我们自己的身边开始介绍，由这些引入到以上的各种名词，下面对这些名词进行形象化的解释，便于理解。</p><p>1：局域网（内网）<br>&emsp;&emsp;小时候家里买了个路由器，接到电脑上，电脑就有网了，接到手机上，wifi接到手机上，手机也有网了。我们就可以说，在这个路由器发射的网络信号让局部范围内有了网络，这个局部范围就称为局域网，而众多的手机，电脑，则是接入了这个局域网的设备。</p><p>2：公网：<br>&emsp;&emsp;现在我们家有局域网了，可别忘了小区内别人家也有路由器，他们也有自己的局域网，那么问题来了，谁给我们和他们路由器连的网？当然是一个更大的路由器了！一个更大的路由器会给你们小区所有的路由器供网。我们同样可以推出在别的小区也有着很多的家庭路由器在提供局域网，而给他们的路由器供网的则是他们小区的路由器。同理可推，给众多小区的路由器供网的是市政级别的路由器，给市政级别的路由器供网的是省的路由器。这样你就会发现整个供网系统就是一个金字塔型，由最上面的一个点向下延伸构建成一个金字塔，塔顶的点就是中央系统。而我们把小区各个用户用的路由器之上的部分称为公网（先把各家各户的路由器给用户家里局部区域供网的范围定义为局域网，把路由器之上的公网系统称为公网）。而整个金字塔的运营商（ISP）就是电信，联通，移动等公司。</p><p>&emsp;&emsp;有了局域网和公网的理解，我们就可以进一步解释 内网IP，公网IP 这类概念了：</p><p>3：内网IP<br>&emsp;&emsp;当别人问:”你电脑的IP是什么啊？”，你大惊失色，马上百度如何查看电脑IP，发现按win+R输入cmd按回车，在命令行中输入 ipconfig ，就查到了自己的电脑IP是1xx.xxx.xxx.xxx;然后你告诉那个人：我的IP是：“xxxxxxxxxxxxxxx”。<br>如果你有过以上的经历，并且认为上述语句并无毛病的话，那么说明你的理解是有问题的（你的操作完全没有任何问题）。下面我会解释为什么：<br>首先电脑IP并非固定的，电脑IP也不是电脑固有的，甚至“电脑IP”本身就是带有歧义的，它会让你认为这是电脑固有的，出厂就设定好的，但其实上不是的，电脑IP是你电脑接入局域网络的路由器来分配的！没错，如果你电脑接入了邻居家的局域网内，你就会发现电脑IP变了。所以这个IP只是临时性的。而且你家的路由器会保证它所分配的IP是各不相同的。</p><p>4：公网IP<br>&emsp;&emsp;公网IP是什么？和你的电脑IP有什么区别？首先我们要知道IP的作用是什么，我给你发了条微信，你给我回信，为什么信息会精准的在我们之间发送而没有发给别人呢？答：因为有IP，只要知道你我的IP，在这个大的金字塔框架中，信息就怎么也走不通。但如果你细想信息在金字塔中是怎么流动的，你会发现我发给你的信息从我的IP出发，到达我家的路由器再到达给我家路由器供网的小区路由器，小区路由器回去上面找市政级的路由器，这个市政级的路由器再找到你小区的路由器再找到你家的路由器再找到你的IP，构成了一条完整的通路，消息在这条通路之中流动。那问题来了，信息怎么知道这条通路的存在呢，信息为什么知道该怎样从当前路由器找到下一个路由器呢？它不知应该知道起点位置和终点位置吗？答：所用的路由器都有一个IP地址，你家的，你小区的，市政的，市政上面的，也就是说在公网里的路由器都有自己的IP地址，都有一个1xx.xxx.xxx.xxx的IP地址，这就是公网IP。但这些IP地址不是由上一级路由器随机分配的，都是固定好的，也就是说公网IP是固定不变的且各不相同的！这样我们也可以说在这个大的网络框架中每个网络用户的绝对地址都是由 公网IP+内网IP 唯一确定的，这是由于公网IP各不相同，局域网内各设备的IP各不相同，这样就保证了对每个用户而言 他公网IP+内网IP 各不相同。<br>我们可以做一个小实验：<br>内网IP查询：电脑cmd中输入ipconfig<br>公网IP查询： 百度内输入IP直接搜索的那串数字<br>我在E601实验室中在实验室路由器的局域网中查询这两项与我接入wifi BUAAMobile得到的两个IP地址都是不一样的。<br>内网IP不同是因为随机分配的，换个路由器就不一样了。<br>公网IP取决于你电脑所连的路由器，E601走的是北航路由器1，BUAAMobile是北航路由器2，两个路由器都不一样，自然公网IP就不一样了！</p><p>如果还是不理解直接看下面的链接视频：<br><a href="https://www.bilibili.com/video/BV1xu411f7UW/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1xu411f7UW/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b6da26061de3320a8170666f06381a91</a><br><a href="https://www.bilibili.com/video/BV1DD4y127r4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1DD4y127r4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p><p>为了下面的叙述，解释一下服务器：<br>5：服务器，说白了就是存储了大量数据的super电脑，有自己的IP地址。你想从服务器得到服务器内的数据，就像你想从老师那得到成绩单：你用电脑微信发送请求：“老师你能不能把期末成绩发我一下”，老师收到请求后在他的电脑上把电脑里面存的成绩单发给你，老师的电脑就相当于一台服务器。你访问www.bilibili.com 请求经过金字塔的通路传递到bilibili公司的服务器，服务器收到请求就把B站主页的数据信息原路返回发送给了你，你就看到了b站主页,之后你想看主页上了哪个视频，也是如上过程。类似于微信聊条，只不过别人回的就是你要看的视频。</p><p>&emsp;&emsp;到这里，你就知道了，我想查询www.bilibili.com，访问请求由内网传到公网，去访问bilibili的服务器，bilibili的服务器再将数据走路由器通道找到我的IP传回给我，我就可以看到bilibili的界面了！<br>&emsp;&emsp;但你有没有想过，你的请求是访问 <a href="https://www.bilibili.com">https://www.bilibili.com</a> 那这条请求访问信息怎么知道该走那条路才能到目标路由与服务器呢？<br>聪明的你显然发现了，<a href="https://www.bilibili.com">https://www.bilibili.com</a> 与bilibili的服务器IP存在着千丝万缕的关系。下面就要讲到域名，DNS。</p><p>6：DNS，你可能会说只要有了目标IP地址，我就完全可以在金字塔体系内进行各种通信了啊，那DNS是干什么吃的？万事万物都有其存在的道理，我们回想一下，你要访问bilibili，那么你就要知道bilibili的IP，就是那一大串1xx.xxx.xxx.xxx，好，我们假设你今天知道了，那你下次还能记住吗？你先记住你女朋友的手机号吧！这就是域名存在的原因，好记！就是好记住，只要访问Bilibili域名<a href="https://www.bilibili.com">https://www.bilibili.com</a> 你就能进去了。但是在金字塔体系里是通过IP找IP来实现通信的啊，因此，就有了DNS—将域名翻译成IP，就是将<a href="https://www.bilibili.com">https://www.bilibili.com</a> 翻译成1xx.xxx.xxx.xxx。具体是怎末工作的呢？DNS实际是一个服务器，你访问某个网址域名时，这个网址域名会先被送到DNS服务器（没有例外），这个服务器内记录了世界上所有的域名和IP的对应数据，查询到后就会将具体的IP传回你的电脑，你的电脑收到后自动去访问这个具体的目标网站IP，就实现了你和目标网站的互通，如果没有DNS，你就只能输入IP访问了。</p><p>7:域名等级：拿 www.bilibili.com来说，.com是顶级域名，.bilibili是一级域名，.www是二级域名。</p>]]></content>
      
      
      <categories>
          
          <category> 计网与操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络知识，IP，DNS，服务器，局域网，公网， </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器端网络加速</title>
      <link href="/CDN%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF/"/>
      <url>/CDN%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>CDN技术是个啥？</p><p>我们先不聊CDN，来聊一聊普通的服务器。<br>&emsp;&emsp;这几天，我买了一个腾讯云的服务器并在我自己的笔记本上配置好了服务器，但美中不足的是我买了地点在广东的服务器，我人在北京，距离算是中规中矩，但距离因素依然是影响网站加载快慢的关键因素，也就是说如果我回到黑龙江，博客的打开速度就会更慢了。<br>有问题人们就会解决问题，那么如何解决服务器和访问用户之间的距离带来的不便呢？CDN就应运而生了，CDN的本质也是服务器，并且CDN分布在全国各地，比如我在黑龙江发出访问博客请求后，如果我开通了CDN服务，那么广州的那台服务器在给我提供页面数据信息的同时选择我身边的一台CDN服务器，将我所访问的资源内容缓存在CDN中，当我再次访问时，就会直接就近访问这台离我很近的CDN服务器，这样就实现了访问的加速，所以其他人（在我附近区域）访问我的博客时，请求同样发到广东的服务器，广东服务器会指向之前缓存过信息的CDN服务器，实现了就近传输数据，达到了提速。当然，这么牛x的服务得加钱。<br>下面的视频可以加深理解：<br><a href="https://www.bilibili.com/video/BV12T4y1P7Fh/?spm_id_from=333.788&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV12T4y1P7Fh/?spm_id_from=333.788&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p><p>带宽，图像显示，图床，云存储COS<br>&emsp;&emsp;在这篇博客中，你看到了大量的图片，这些图片的大小超过50MB，而我所购买的服务器带宽是4M，所以要加载出所有的图片，就需要50/（4/8）=100s，而且这还是在我没有带宽损耗，也就是我人得站在广东那台服务器旁边才能有这种速度，随着距离的增加带宽发生了损耗，导致距离越远数据传输越慢（这也就是为什么需要CDN来消除距离因素）。但你会发现，就算有CDN服务器，我网站的加载完毕时间也只能逼近100s，那该怎样缩短时间呢？<br>当你打开互联网上的任何网站，实际上你打开后只花了不到十秒就全加载完了，我们反观加载的原理，网站内容按照加载所需带宽大小可以分为两部分，正常内容和图片（占大比例的还是图片！），因此我们可以在加载图片上动手脚，那么如何更快加载图片呢？<br>&emsp;&emsp;想更快加载一张图片，要么提升服务器的带宽，要么处理图像自身。下面我们来谈谈云存储技术，我们在做包含图片的网站时，经常把图像本身传到服务器中，以方便服务器调用发送给访问者，但服务器的带宽有限，我的就是4M，那怎样拓宽呢？首先腾讯云在卖服务器的时候就对带宽明码标价了，所以广东的那台腾讯云服务器本身的带宽就不用想了，但如果我们把图片存到其他服务器呢？用其他服务器的带宽来传输图片，你肯定会说，你这不就相当于自己又买了一台服务器来存图片吗？你说的没错，但也不完全对，我买的是有特定功能的服务器（存储类服务器，也就是云存储COS服务器，相比正规功能的服务器，这种特定功能的服务器极其便宜），就是我把网站要显示的图片存在了其他云服务器上，并生成访问链接：HTTP://XXXX。在博客网站的生成代码中我把图的访问路径换成了HTTP://XXXX 这种链接，如下：<br><a href="https://blog-1315294080.cos.ap-beijing.myqcloud.com/19.png">https://blog-1315294080.cos.ap-beijing.myqcloud.com/19.png</a>  ，点击链接就可以生成图片</p><p>&emsp;&emsp;这样有人在访问我的博客时，广东的服务器在加载博客网站的图片时，会访问这个图片的网址，这个网址部署在云存储COS服务器上，因此云存储COS服务器就会用它自己的带宽给我加载图片信息，这样就节省了广东服务器的4M带宽！因此就相当于你在打开我的博客的时候，传输资源的带宽=广东4MB+云存储COS服务器的带宽，一起加载。将图片转化成网页链接的过程，就是图床技术。因此同理，云存储技术还可以将文档，视频，音频如此操作，因此云存储可以针对很多类型资源进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> 计网与操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN 图床 图像显示 带宽 云存储COS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发者日志</title>
      <link href="/%E5%BC%80%E5%8F%91%E8%80%85%E6%97%A5%E5%BF%97/"/>
      <url>/%E5%BC%80%E5%8F%91%E8%80%85%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/yunyuye.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><div class="note default simple"><p>default 开发者日志</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-11-21 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">1.0</a></p></div></div><div class='timeline-item-content'><p>本博客网站开服，作者：yhl2333<br>学校：北京航空航天大学<br>邮箱：1652966670@qq.com</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-11-23 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">1.1 -&gt; 2.0</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;好不容易把bug改完了，把功能实现了。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-11-23 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">1.0 -&gt; 1.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;今天是11月23日，新增了留言新功能，希望大家可以对博客网站提出建设性意见或者有什么想留言的。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-11-25 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">1.1 -&gt; 2.0</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;今天是11月25日，本着精益求精的态度，我对博客进行的大幅度的美化与修缮，成功实现了白天黑夜不同的界面显示与特效。这个过程历时整整一天，出现的问题：修改博客文件后在本地 host:4000端口打开的效果和在浏览器中服务器IP地址打开的效果不同，不同之处在于修改的部分没有显示。进过多次调试查证发现是浏览器自己的数据缓存功能，慨叹自己如此伞兵的同时也对浏览器的搜索引擎的检索能力提出质疑。浏览器的数据缓存：浏览器在加载网页之后会将内容缓存到你的设备上，当你再次访问（包括刷新网页）这个网站就会优先显示上一次加载缓存过的结果，而不是默认立即从服务器上更新全部网站内容，不然1GB的流量打开几个图片量大的网页就都没了。这也就导致了网站的开发者修改过服务器上的资源后刷新网址网址会没有任何变化。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-11-29 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">1.1 -&gt; 2.0</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;直接润回家！润的前一晚学校🐏了一个，润的当天🐏了一个。（润的后一天也🐏了一个）（再往后一天和我一层的同学也阳了，一层被拉走隔离了。。）<br>&emsp;&emsp;今天遇到了好多有趣的人，拼车的学姐，开出租的老父亲，做志愿奉献社会的兵哥，每个人都有着我所羡慕并且精彩的生活，<br>&emsp;&emsp;逢人便讲自己的憨厚懂事的高三儿子的出租车父亲，热情的和我讲述自己的孩子如何努力，如何憨厚可爱，如何高三了还孩子气，讲述的时候发自心底的开心与骄傲像极了我的父亲，虽然我不那么懂事（回家发现俺爹真的把烟戒了，挺开心的）。<br>&emsp;&emsp;在拼车群里拼了一天的车都没拼到去北京朝阳站的人，第二天拼到了一个林业大学的研一姐，和我一样也是趁着疫情赶紧润回家，老乡所以在一起聊了还算挺多的吧，值得感叹的是我依然还是和异性交谈九级伤残选手，也不太会表达，但单方面也没感到尴尬。<br>&emsp;&emsp;三四十号转运的人在天寒地冻的大街上冻了一个小时，怨气朝天地上了转运大巴，面对大家的埋怨挖苦，开车的军人哥忍气吞声还疯狂打趣，让车上的气氛缓和了下来，后来知道他是无偿来当志愿者的，理由是想要奉献社会，从早上七点干到晚上十点，很难想象一天中他咽下了多少波分流人员的怨气，令人打心底敬佩，无论如何，给别人多一些容忍与理解吧。<br>&emsp;&emsp;哈西站下了高铁，走在站里有种恍然若失的感觉，感觉愧疚又无力，不知不觉就泪流满面了。高中写了三年的触景生情，好像到了今天才算真正理解了<br>&emsp;&emsp;回家后和杭州的姐姐打了会电话，一切安好，希望今年过年的时候能见到吧<br>&emsp;&emsp;很精彩有趣的一天<br>&emsp;&emsp;三点半了，睡觉</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-1 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">1.1 -&gt; 2.0</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;隔离第二天。已经感觉得到自己精神层面出了些状况，可能是真的有太多太多想找人说说吧，可大家都在忙，也不去打扰了哈哈。<br>&emsp;&emsp;感觉这么多年自己就一直都在念书，大部分还都是无用功。感觉别人的生活都好精彩啊，好想走出去看看啊。引用彭哥的一句话“没有生活质量慢慢就抑郁了呗”，但比起身边的人我已经算是不错的了。北京看样子要解封了，脸都不要了。<br>&emsp;&emsp;好久没更技术篇了，明天更一篇C++出来。<br>&emsp;&emsp;今天属实是没啥正能量了，，<br>&emsp;&emsp;都别跟自己过不去吧，<br>&emsp;&emsp;加油吧大伙</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-5 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;开放了评论区，用的必来力评论系统网站，大家可以放心评论不用担心号被盗哈。。。号被盗了我全责好吧</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-9 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;ELDEN RING！年度最佳 2022-12-9，出个DLC直接攒钱买显卡去实验室玩。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-26 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;考研结束了，兄弟们都回来了，就算家不在肇东，大家也都第一站回到了肇东。对我来说，可算有人陪着说话打游戏了，不管考得怎么样，都先把一切都放下吧，休养一段时间。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-1-1 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;欢度元旦，给朋友们都发了贺词，鸣谢王哥凌晨帮助我度过情感难关解开心结。希望新一年能够认识到很多志趣相投的人，多交几个朋友。多学一些知识与社会技能，提高自己的生活质量！新年愿望是让自己变得博学谦逊。女朋友等毕业了再说吧。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-1-5 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;一根藤2023年度首聚。和大伙一起去了人工湖，看了烟花，打游戏出去住。得知桂花已经找了工作，感觉像是葫芦娃中大哥被妖精抓走了一样，七个人中第一个能早日实现经济自由和生活自由，工作也还不错。看来大家都别来无恙，即使生活充满了挫折也在努力改变自己的人生，接纳自己。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-4-12 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;做毕设的同时，重新更新了博客界面和博客内容。又接了一份毕设，要自己去大兴区出差了。说实话心里很没底。买了挺多设备花了挺多钱，等W教授发劳务买波A卡。目测找工作那年学历贬值加剧，也见识到了实验室的师兄出众的能力，打算从研一开始就锁定研究方向也方便以后找工作，和凯翔交流之后，目前定在了SALM。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-13 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;北航国际文化节，效果放在整个大学期间也是相当炸裂的存在，参照以往的校庆真的是好的不能再好了。很有特色，吃了许多风味小吃，和一些外国人合影留了念，裴济的肌肉小哥，漂亮的俄罗斯小姐姐（真的太好看了吧）。集了三十个国家的印章，听了歌舞，简直太满意了。也见识到了金钱与科技的力量，专业相机加修图直接化身专业摄影师。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-22 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;规划去西藏第一步，打算租个专业照相机。假期打算把SLAM和深入理解计算机系统看完，书可太厚了。SLAM，Linux使用，深入理解计算机。打算在答辩之后去录一些校园的vlog，也可以去沙河拍拍日出剪个视频发到b站上。看到蔡哥剪的视频很是震撼。因为大学前三年是混过来的，没怎么融入到大学生活中，所以感觉想弥补一下遗憾吧。从去年十月份开始到现在自己也算是没闲着，这学期更是离谱，一个学期更是一点都没闲着，也就放了一周的假期。也抽时间把博客重新优化了一下，学了下怎么写Markdown文本。之后就会一直更新了。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-29 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;本科结题答辩结束，晚上八点慕名去了国贸CBD。我本以为三里屯已算的上是极限，奈何国贸这建的是真的更好，肉眼可见的富到流油。不得不慨叹在这里面行走是真的压抑，仿佛像《高老头》中主角第一次踏入巴黎的上流社会一样，我第一次怀念起了家乡的淳朴。国贸商城里尽是些见所未见的奢侈品品牌，几乎全是表啊，珠宝啊，包啊。说起来也可笑，细品隔着橱窗看这些东西的感觉和卖火柴的小女孩隔着橱窗看富人宴饮应该也差不多了。完美诠释了世界在我眼前却又永远遥不可及，有种过街老鼠想要马上逃走的感觉。但想到出没于此的人本质上也不过是普通人，我和室友还是硬生生沿着国贸桥逛完了整个CBD。然而端庄大气的国贸脚下是望不到尽头的老破小，人行路边停满了数不清的996们的电瓶车。现在想起那些进京进沪拼死拼活工作的人就感到也挺五味陈杂的，人各有志吧。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-3 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;六月末给自己请了一段长假打算毕业旅行，先是和高中同学去张家界，然后去成都和室友去西藏走318线。我认为我应该往远了走一走，看一看，去看看未知的世界，自己憧憬的地方。虽然花了一万，但我认为很值得。旅行的过程中，我碰到了司机昊哥，没到三十岁，打算到30不结婚就整个中国旅行，抛下家里的压力给自己空间与自由，无法评价，自己认为值得怎样倒都无所谓。碰到一对从事医护行业的新婚夫妇，刚刚结婚，上了八个月的班来休婚假。很幸运遇到他们，不单单是相处的异常快乐与融洽，这次旅行除了旅行本身，还观测到了许多生活层面的东西。相恋七年结婚，挺羡慕的，哎羡慕死了。又有许多自己的爱好，有美好的家庭，除了没有很多自己可支配的时间。他们给我的共同感觉是人在三十岁左右必然会被生活压得喘不过气来，他们一直像兄长一样给我建议，即进入实验室以后我第二次感觉到自己和生活严重脱节了，每每和不同圈子的人接触，我都感觉弗如远甚。这种感觉来自于方方面面，要么完全没有了解过，要么肤浅。这次旅行我学会了如何摄影以及怎样去修图，虽然都是入门级，但也确实成为了爱好，也被许多人称赞拍的好看。总之318绝景太值得了，拍的照片真的好看，听到看到学到了好多东西。<br>&emsp;&emsp;一个人的毕业旅行还真的挺好的，主要运气好碰到了这么棒的队友。看到一个大师兄刚毕业就领结婚证了，羡慕。另一个大师兄应该也快了，酸上加酸哈哈。关于以后进私企还是国企，我感觉现在反而无所谓了，想要干自己喜欢干的行业，在私企才有可能；想稳定安家买房，国企会更容易，无论以后选择了哪一条路，我都不会对自己有什么怨言。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-7-4 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;拿到了学位证书和毕业证书，也拿到了沈元荣誉学院的荣誉证书和北航校优秀毕业生证书，整理了毕业照，特此纪念。和大师兄还有大师姐合影留念了。想起去年九月进组到现在毕业，大师兄完全做到了大师兄应该做的，包括帮助师弟云云。忽然现在才回过味来大师兄怎么这就这么走了啊，阿民给了我很多帮助与指导，深深记得我无法参加大师兄的送别宴，大师兄在601门口目送我去赶飞机，那次是我们最后一次见面，但也真希望以后还会再见，如果我够强的话说不定还能做个同事。总之祝大师兄一路顺风</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-9-8 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;成都和阿拉善出差归来，不得不说成都是我见过最适合人居住的一线城市了，人口结构正确，消费水平正确，经济正确。在阿拉善拍到了各种云延时，扫街街景，大漠的风光，吃的也是更没话说，趁着这期间还又修了一遍《数据结构》和1/3的《操作系统》，也是时候准备回去入学了。我希望学一些本领这句话不单单停留在嘴上说说，成也三年，败也三年。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-9-17 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;今天迪庆师兄请吃饭，我也和展平哥深入探讨了一些关于未来规划上的事情，不得不说展平哥确实综合实力强悍，无论是学术还是社交上，典型多线程互不影响，很清楚什么时候该做什么，眼界比我不知道开阔了多少。忽然感觉好像还可以继续出国读博，需要哪些必要条件，如何去读，去哪读。说实话我很想要博士这个Title，一是想去搞一下真正的学术，发论文做研究，另一个是不想给这么多年的学业草草划上一个句号，因为一切都是如此的来之不易，人也，命也，运也；机会存在就要去努力抓住。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-23 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;伟大，无需多言。今天我自己终于把厕所毒瘤收拾好了，刚入学的时候就差点不敢进卫生间，上次把洗浴的地方收拾了一下，我被恶心的不行，险些直接吐了，收拾完洗浴的地方也就把马桶区搁置掉了，要是当时有个朋友支持我一下我可能马上就把马桶区收拾掉了吧。过了一周我也真的忍不了了，不想面对的总要去面对，把剩下的洁厕神器用掉了，终于干净了。仅凭言语真的不能表达我心情的千万分之一，没见过这么脏的地方。总之，伟大，无需多言。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-23 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.0 -&gt; 2.1</a></p></div></div><div class='timeline-item-content'><p>&emsp;&emsp;</p></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人们为什么想在大城市定居？</title>
      <link href="/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1/"/>
      <url>/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;先和大家小算一笔账。<br>&emsp;&emsp;本人预计三年半后毕业，假设进入航天科技一院工作并拿到北京户口，想要在北京/杭州/武汉等超一线，一线城市落户，(假设房价不增不减，假设没有天灾人祸)我要多少年才能买一套房子（算公摊80平）？</p><p>&emsp;&emsp;这里以北京房价计算</p><p>首先我认为不应该选择从小户型比如50平米向80平米过度，原因有二：<br>1：居住舒适程度来说，两个人(假设我到时候能找到对象好吧)居住面积小于50平米的话必然会很难受。<br>2：将50平米卖出会有亏损，并且十年之内也不可能还得完房贷。届时房价如果继续上涨，会比直接买80高上太多太多（租房同理）。</p><p>&emsp;&emsp;北京房价：五环南，北京公认楼价便宜的地方，6w/m^2。 这样6*80=480w。<br>&emsp;&emsp;我的工资，假设我毕业的时候就业形势和今年一样明朗（烧高香了）。四年后税后平均工资35w每年（个人所得税上缴20%）。</p><p>&emsp;&emsp;好，接下来计算工作前三年住员工公寓积攒的工资和买房贷款产生的利息，前三年税后（20+25+30）=75w。减去三年各种开销（每月2k），75-12<em>3</em>2k=68w，加上公司给的安家费，省吃俭用一共攒下80w.<br>&emsp;&emsp;去银行贷款（480-80）=400w。按还20年计算，这些贷款在20年内会产生至少250w的利息。这样（400+250）/35=19年。<br>&emsp;&emsp;相当于我不吃不喝把自己的工资全部投入，也要将近20年时间才勉强还完，且在这20年间不能出现任何形式的变数。<br>&emsp;&emsp;这样，另一个人的工资要完全用在家里开销上。就北京的存活物价与日常消费，勉强能养活两个人。<br>&emsp;&emsp;现在第一个问题来了，要不要孩子，根本就养不起，孩子怎么养，要多少资金投入，想都不敢想。也就是说很有可能当我快50的时候，我才把一切都安顿好，这时恐怕会身无分文。<br>&emsp;&emsp;现在第二个问题，如果在这二十年期间，漂浮的房地产泡沫破碎，经济危机怎么办。可以预见到的是欠银行的钱要一分不少的还掉，工资会大幅降低。如果真的发生这种事情，其实就可以/remake了，风险巨大。<br>&emsp;&emsp;所以目前的形势来看，为了一张北京户口，大半辈子基本上寝食难安。本来就没什么先天充实的经济基础的话，北京户口还真就是废纸一张。</p><p>&emsp;&emsp;那么父母是如何看待这件事的呢？</p><p>&emsp;&emsp;在我家经常听到的一句话就是“有多少人做梦都想拿北京户口都拿不到，你脑子有问题吗不留北京？”，我不禁要问，我为什么要留在北京？<br>&emsp;&emsp;“为了以后你的孩子以后就留在北京啊！”。<br>&emsp;&emsp;“………….”<br>首先老一辈人为什么会无脑认为大城市好，特别是北上广深<br>1：其实这么认为的都是东北人居多，因为从小到大都穷惯了。以前在电视上看到的先进，富裕的代表城市就是北上广深，听得多了也就认为理所应当了。听到在北京工作几年就能能拿30w+的工资就认为这工资太高了，潜意识里认为能满足生活所需。但问题是真的不够，甚至远远不够。<br>2：听单位同事云谁家孩子留在北京上海了，听的多了就会把能否定居北上广看作是孩子是否优秀成功的标准。其实你回想一下，这和让初中考到重点高中的尖子班，高考考到985，211何其的相似，这次变成了家是否安在了北上广深。这其中甚至可能掺杂了虚荣心和攀比作祟，她们只关心这一结果能否实现，而忽视了现今的生存成本，竞争压力，后代养育，经济形势等一系列在她们时代并未如此严峻过的问题，而这些问题在中国的超级城市中只会被无限的放大。如果你问她们孩子怎么养，谁来养，养育成本怎么办？大概率会和你说“你这么大都养过来了，这个社会上谁家还不得养个孩子呢？你面对的压力大家都在面对”云云，殊不知这个时代每年有1000w的毕业生却只有不到70w的新生儿，男女经济都独立的情况下由女性主持家务，养育子女已经变得不公平与不现实。<br>3：典型的中国式父母思想，“为了后代”这种说辞就是典型代表，生活的幸福感本就不多，996，007就导致根本就没有时间放松自己做自己想做的事，生命中的前三十年努力学习，再加十年，二十年的班，一辈子累死累活是吧，就为了让孩子扎根在北京？得了吧，他有能耐自己考北京去呗，他没能耐他也守不住家业。典型的中国式家长思想，生活有多艰苦无所谓，为了孩子好咋都行。纯属是被几次改革标语被洗脑了。</p><p>&emsp;&emsp;人来世上一遭，埋头苦干一辈子，来也匆匆去也匆匆，除了一个房子，一个孩子，一张标注着户口的废纸，一点活过的痕迹都没有。可悲又可笑。<br>这辈子我能为我自己活一活么？</p><p>&emsp;&emsp;你会说还非在北京不可吗，好，退一步，省会城市。<br>&emsp;&emsp;其实道理是一样的，经济好的地方工资高，经济差的地方工资低，你不妨拿出纸笔计算一下，还房贷的年数和北京没差多少，该面对的问题也是一样也不会少。<br>&emsp;&emsp;现在的年轻人也都不傻，和以前人们宁可打工也要进城一样，毕业生肯定会把省会级城市（除边疆贫困地区省会）列入第一梯队考量。这样你会发现，和北上广深一样，自己还是被一群相同目的的同龄人裹挟着，被迫选择这些省会城市。<br>&emsp;&emsp;三线四线城市也还是不会去的，岗位更少，工资更低，你自己都会想对得起自己的寒窗苦读吗。<br>&emsp;&emsp;所以我们发现在哪里好像都挺难，还不如卷去北上广，起码能满足一下虚荣心，甚至会安慰自己北上广有更好的社会福利，平台与机会更多，有隐性福利如五险一金，医疗条件好，代价是要比省会城市更辛苦一点。<br>&emsp;&emsp;至此，兜兜转转回到了起点，闭环形成了。</p><p>&emsp;&emsp;因此无论在父母还是我们的角度上，我们也似乎不得不往更高处走。</p><p>&emsp;&emsp;不过到现在，我们“活不起”的问题依然没有解决，我还是活不起啊！华生，你发现了盲点，如果只为了自己的话，问题可能就解决了。自己可以住五十平的房子，自己也不用担心婚姻问题，也完美规避了养孩子的问题，能完全按照自己的意愿支配自己的开销，在委屈自己的同时也不会带上其他人。现如今这么多的人选择不结婚，不要孩子，与其说年轻人想要自己过活的快快乐乐，不如说当今的社会形势下就不适合婚育，面对未知的婚姻问题与养育问题，在大城市中年轻人根本没有容错的余地，稍有不慎就可能事业家庭尽毁。生物都知道环境恶劣资源匮乏时会限制自身种族的繁衍，何况是人。</p><p>&emsp;&emsp;但当你决定拿出全部积蓄在大城市贷款买房了，你也就基本上扎根这个城市一辈子了。<br>&emsp;&emsp;最好的例子就是成都，08年大地震有多少人想去华东生活远离地震带的，结果发现他们根本就出不去。当你80%-90%的资产是房产时，想走？对比起，这是你家几代人的努力成果，你确定要放弃户口的同时贱卖掉房产吗？不可能的。这也是为什么超一线城市和一线城市的楼房性价比高的原因，保值啊，楼价再怎么跌，再怎么发生天灾人祸，想来大城市的人也大有人在，市场这么大，楼价会下跌？太抽象了，不存在的。</p>]]></content>
      
      
      <categories>
          
          <category> 社会现象分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 房价 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>房地产经济为何主导了经济的发展</title>
      <link href="/%E5%9C%9F%E5%9C%B0%E9%87%91%E8%9E%8D/"/>
      <url>/%E5%9C%9F%E5%9C%B0%E9%87%91%E8%9E%8D/</url>
      
        <content type="html"><![CDATA[<p>为什么说楼市推动了整个中国的发展？GDP飞黄腾达的第一支柱是楼市？</p><p>&emsp;&emsp;分税制实施前，全社会还在吃大锅饭，没有经济活力，工业实力与生产能力过于落户，发展太过缓慢。1978年11月24日，出现了第一例土地包产到户，也就是自己给自己干活，收入上交政府一部分剩下都是自己的。 这样成功刺激了人们的劳动积极性。底层的收入模式发生了改变，顶层的收入模式也要变，因为说白了以前一切劳动产生的价值归中央，现在劳动者和企业自己干自己的，收入也都是自己的，中央就没钱了，中央就说不行，你得把你赚的一部分给我，也就诞生了分税制的雏形包干制，就是把利润上交给上层，但这样就代表着如果当地没赚钱，就不必缴纳，因此在账上做手脚也大有人在，很快国库就没钱了。<br>&emsp;&emsp;地方政府有钱了，中央政府又没钱了。于是诞生了包干制pro—分税制，从生产材料，售卖的整个过程都要上税，无论是否盈利，相当于变相增加了产品的成本，只要有交易，就有源源不断的税收，这样中央一定能有稳定的经济收入。中央政府与地方政府73分，地方政府说：怎么我们才拿七成啊？中央财政部表示：七成那是中央的！中央拿税收之七，省政府，市政府，县政府共拿税收之3。不管地方愿不愿意，反正最后是都同意了。</p><p>&emsp;&emsp;这样中央政府有钱了，地方政府又没钱了，地方就会觉得，我拿的钱少干的事还多，属于是上头点菜地方买单了，这3成税，还要养活省政府，市政府，县政府，基础设施建设都要从里面拿钱，上层权力高，越往下分的钱还越少，这也就是为什么省里待遇比基层强不少。这就是财权层层上收，事权层层下压。中央财政蒸蒸日上，省级财政稳稳当当，市级财政摇摇晃晃，县级财政哭爹喊娘。</p><p>&emsp;&emsp;那这样地方活不了啊，哪有钱搞治安，搞教育，搞医保民生？<br>&emsp;&emsp;不知道你们有没有看过市政的新闻频道，我家在一个十八线小县城，在新闻里我经常能听到“招商引资”的字眼。在巨大的财政压力下，地方发现了又一座金矿，之前中央说税收拿七还有另一项并行措施，就是把土地出让金额给地方政府，至此，万恶之源开始出现，我们一辈子的终极目的—房，登上了历史舞台。土地房地产和招商引资有什么关系？</p><p>&emsp;&emsp;首先说明：近二十年来，我国经济发展迅猛，迅猛到在初期就可以做到经济翻几番，不过令人感到遗憾的是，绝大部分归功于土地兜售和土地金融，而非制造业，工业进步与科技进步。<br>&emsp;&emsp;再给大家解释一下贷款，比如说我有100元，存进了银行，那么银行可以把这部分钱贷款给别客户A，（此时我和A的银行卡里都有100元，我们都可以去市面上消费）这样市面上就相当于有200元可以流通，这时我和A把钱全部在超市里用掉，花掉200元购买商品，这也就是说实际上只靠我自己的100元，就实现了价值200元商品的购买！但是A是要把这贷款100元加上银行利息还给银行的。但在他购买商品的那一刻，他是无力偿还一分钱的，也就是说A把欠款的偿还赌在了未来的收入上，因此贷款的本质就是对未来的透支。还远远没有结束，A把钱消费给了超市老板B，老板B可是实打实得到了100元，如果B把这些钱存入银行，银行是不是就可以把这些钱贷款给用户C！这样B和C就又重新构成了我和A的关系，此时如果“我”，“A”，“B”，“C”将手里的100元都花出去了，相当于我的100元在市场中可以购买400元的商品！简直离大谱。同理，这样的模式还可以延续到D和E，F和G…..这样最开始的100元就通过贷款，在市场中可以兑换的价值不断翻番（银行中贷的款也在增多，不过随之经济发展，未来一定能还上嘛）。但可以兑换的价值肯定也不是无限上涨，上述只是理想情况，现实是国家规定中央银行只能拿储户个人存款的90%拿去放贷，这就导致，我存100，A贷款到90,B存90，C贷款81，这样依据等比数列求和往下推，这100元最多只可以购买1000元的等价物。神奇吗？这与地方房产，地方财政收入有什么关系呢？</p><p>&emsp;&emsp;下面来解析地方政府是如何增加自己的财政收入的。只有国家吃剩下的三成税收是肯定活不起的，地方政府发现土地可以大做文章，中央政府给了地方政府土地的“使用权”，也就是地方政府可也把土地外包给企业，这就是所谓的招商引资，有企业了，那企业的这些打工人应该去哪里住呢？当然是就近买房了呀！于是政府就又划出一片地给房地产开发商，用于楼盘开发，给人们提供居住场地。<br>可以看到，政府将土地租给了房地产开发商和企业以得到市政收入，但这两片地的类型存在着本质上的不同：卖给企业的地每平方米1000左右，卖给房地产开发商的则要比这个价钱贵上1000倍以上。</p><p>为什么要这样做？<br>1：如果市政招商引资把土地卖得太贵的话就没有商人企业进入了，相反，租给商人的地越便宜，来的企业就越多，引入的资金量就大，提供的就业岗位就越大，拉动更多的人进入城市居住，提高贷款买房的需求。可以建居民区的地价也就水涨船高，政府可以向银行抵押地价更高的地，贷出更多的钱，用以城市建设。<br>2：城市化进程中，为了活得更好的生存，教育，医疗条件，“人往高处走”是必然的趋势，而一个城市的市政收入越多，这些也就越完善。<br>3：如果每个人都背负着十年二十年的房贷，是不是有利于城市长期的稳定建设？（减少人口外流，增长城市人口，拉高教育医疗等行业消费水准）</p><p>&emsp;&emsp;可以看到，以上三条中任意一条都对另外两条有正反馈作用，即促进另外两条的发展。你也可以看到现在的状况，农村人口流失严重，有条件的宁可背上房贷也要进入更好的城市。可对于政府，市民来说，这些似乎都是没办法的事情：地方政府想要完成中央给的GDP指标，政府只能靠房地产业拉高GDP，几万元从农民手里买来的土地，然后几千万卖给房地产开发商，这个赚钱的速度当然没有任何生意可以比拟的，因此，土地财政就是鸦片一样，每个地方政府都会上瘾的，每年卖几块土地，财政问题就解决了，这样工作轻松，压力不大，政绩斐然！同时由于地方政府在从包干制转到分税制的时候就已经没有钱搞乡村的基础设施建设了，导致人们几乎同时涌入了城市。一夜之间，工厂如雨后春笋般在城市里建起，看着高涨的房价，民众争先恐后涌入城市，留下了几乎没有任何变化与发展能力的农村。就算今天中央想出政策振兴农村，想让年轻人回到农村，晚了，已经晚了，年轻的早已在城里结了婚还上了房贷，就算现在政府有钱了要将农村的基础设施做好做大，也难以吸引年轻人反乡了。我们现在能看到的基础设施建设，也仅限于县城往上，县城以下大部分农村连学校都倒闭了，就算有也不可能保证质量，把孩子送到城里读书已经成为每个农村家庭的信条。<br><img src="/img/gover.png" alt="地方政府运营模式"> </p><p>&emsp;&emsp;如果你关注过我国的股市和楼市，你会发现，股市怎么变，股市对GDP并没有太大影响，楼市及楼市的附带产业才是GDP指定亲爹。房地产业的产值每增加1个百分点，就能使相关产业的产值增加1.5到2个百分点。在我国，每增加1亿元的住宅投资，其他23个相关产业相应增加投入1.479亿元，被带动的直接相关或间接相关较大的产业有60多个。<br>&emsp;&emsp;房价能跌吗？糊涂啊！跌了某国经济总量不就跌了吗，地方政府的80%的负债还要靠卖地和地价的升值来偿还，往小了说，房地产是个人的身家，往大了说，这就是国运！<br><img src="/img/ground.png" alt="GDP与楼市"> </p><p>&emsp;&emsp;因此，在我们看到某国GDP跃居世界第二的同时，我们就应该意识到，万事万物都有其代价，市政向银行贷的款不还了吗？拿什么还？贷款的本质是透支未来啊，未来会还的！确实，贷多少，未来都能还。当年日本也是这么想的，甚至一个东京市的房地产可以买下整个美国（这就是贷款的力量！）。结果房地产泡沫破碎，社会直接停摆了二十年。我们现在的社会：人口多，资源有限，竞争激烈，老龄化严重，生育率达到谷底，和当年的日本几乎是一个模子刻出来的，我们虽然发展迅猛，但同日本一样，隐患严重。</p><p>&emsp;&emsp;那国家为什么不把钱更多的投入到科技高新产业的建设来实现转型呢？事实上，国家不论以任何目的把钱放下去，资金的流动去向是不会骗人的，因为天下的所有人都知道楼市赚钱啊！哪里能生财财才去哪，最终这些钱殊途同归，大部分还是流到了楼市里而不是科技公司的股市中，还是助长了房地产事业，这也就是过去十几年中房地产暴涨的原因。<br>&emsp;&emsp;房地产经济如何才能高高的升起，悄悄的放下呢？<br>&emsp;&emsp;现如今，中央政策选择改变杠杆率，也就是地方的土地在银行中能够抵押出来的贷款金额来限制房地产的主导地位，刚刚实施，未见成效。<br>&emsp;&emsp;能否转型成功，直接影响以后历史书上怎么评价现代人的功过得失，毕竟未来的人可不想给我们还债。可以确定的是，能够书写历史的人，在评价前人的正确性上要远远超出评价自己的，并且也不会留下一丝情面。</p>]]></content>
      
      
      <categories>
          
          <category> 社会现象分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分税制，土地政策，土地金融 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业生怎么总找不到好工作?</title>
      <link href="/%E6%AF%95%E4%B8%9A%E7%94%9F%E6%80%8E%E4%B9%88%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A5%BD%E5%B7%A5%E4%BD%9C/"/>
      <url>/%E6%AF%95%E4%B8%9A%E7%94%9F%E6%80%8E%E4%B9%88%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A5%BD%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;如果年度词汇可以选负面词汇的话，我相信，这个字只会取自两个方面：<br>1：疫情下经济低迷与人的精神问题<br>2：卷（多多少少带有本人的个人恩怨，但不影响与第一个方面并列）</p><p>&emsp;&emsp;我们为什么越来越难找工作了呢？为什么考研考公还在水涨船高？这种病态的考试应试系统为全社会都看在眼里却默不作声？</p><p>第一个问题：首先工作为什么越来越难找？<br>&emsp;&emsp;我感觉随便找个大学生出来他都能答出来：疫情之下经济低迷，各行各业（餐饮、零售、交通、旅游、等等等等）受到牵连，社会流动资金缩水，岗位缩招。拿互联网公司来举例，大公司因为资金短缺问题都能把整个研发部门给裁掉，没有经济来促进行业发展，招聘的毕业生自然而然就少了。<br>总之蛋糕变小了，能养的起的人数也减少了。</p><p>第二个问题:为什么考研考公水涨船高？<br>&emsp;&emsp;在回答这个问题的同时，先回想一下你的父母是不是曾经说过当年考上大学是多么多么困难，考上了就会分配工作以后生活无忧等等。<br>第一个关键点出现了，我们感觉现在好像考个大学有手就行，但当时非也，这种现象和当时的社会经济与教育资源有关，南方我不知道，北方大部分父母在小学初中毕业以后就会辍学种地，去城市打工减少家里的压力，一家好多个孩子也就会有一个或两个去读高中。好，现在都还很容易理解，那么列出1995年和2022年的高等教育适龄入学率（即同龄人中，上大学人数比总同龄人数）：<br>1995年：5.3%<br>2020年：54%<br>对比周边国家：<br><img src="/img/2.png" alt=""><br>&emsp;&emsp;从上面的数据不难看出，从前的大学教育是精英式教育，现在的大学教育是大众式教育。<br>&emsp;&emsp;那么什么时候开始有计划性的扩招了呢？<br>&emsp;&emsp;一切社会问题的产生永远都避不开一个要素：经济。毕竟整个地球史上就没有生物会和钱过不去的。<br>&emsp;&emsp;首先阐述一个事实，教育和经济是双向互补的。<br>&emsp;&emsp;去问问你的父母，1999年很重大的一件事，下岗潮。那一年国内市场经济下行，当年产生了1000万的下岗工人（没上大学的还是有充足的岗位去处的），年轻人不进大学，就会和全体工人一起竞争，在市场有限的条件下，社会矛盾会激化，因此就决定让更多学生进入大学。大学生进入大学，除了缓解当年的就业，下岗在就业的压力，还可以带动经济的发展，因为父母在看到扩招之前的大学生是如何风光，砸锅卖铁也都会供孩子上大学，这样本来停滞的经济也就开始流动起来，比如学生的住宿费，伙食费，可以促进学校引入师资和校舍和当地商业的发展，小学，初中，高中的大规模兴办，教师行业的兴起（你细品什么时候高中大学开始收学费的），学生的出行可以给铁路的建设提供资金支持，铁路建成则促进了各地经济的快速发展，因此这是当时市场经济的一剂强心针。<br>&emsp;&emsp;于是乎在1998年15大上就决定大学扩招，决定在2010年将上面的高等教育适龄入学率扩大到15%。于是1999年就是“大学扩招”年。但令人啧啧称奇的是这个计划在2003年就达到了15%，整整提前了7年。<br>我们可以看出，当年的大学扩招成效：<br>1、成功缓解了下岗潮的压力<br>2、成功促进了经济的发展，在2002年就达到了本来计划在2010年的15%大学入学率，足以证明这项举措是多么有成效。</p><p>&emsp;&emsp;好，再转向今年的考研考公，如果你观察数据可以发现，考研人数暴涨：<br><img src="/img/3.jpg" alt=""><br>&emsp;&emsp;2021年450w，2022年540w，足见经济形势的困顿，暴涨的背后伴随着教育部对研究生进行了扩招，同样的经济困顿，同样的扩招，此时此刻恰如彼时彼刻。<br>那如何处理当今的问题呢？<br>&emsp;&emsp;答：—“抄作业”—</p><p>&emsp;&emsp;打算直接复刻1999荣光是吧。当年的缓兵之计卓见成效，但如今的缓兵之计则不太行。区别在于：<br>1、缓兵的这几年经济并没有增长，就业岗位不增反减。经济没有增长的原因是疫情下的政策束手束脚，经济必然后退；还有就是Trump的贸易战，（有人说Trump贸易战输了我就想笑，贸易战确实是伤敌1000自损800，但问题是1000对人家来说不痛不痒，800对我们来说如数家珍），我国经济分为国内市场经济和海外进出口经济，国内市场经济被疫情拖累，海外进出口经济则被Trump咬住。这两方面导致了经济没有活力，导致经济下行<br>2、当1999就算扩招了，但绝大多数人还是上不了大学，和绝大部分适龄青年依旧是毫无关系，构不成激烈的竞争。现如今是却一个几乎全民大学的时代，扩招则就象征着内卷走向合理化与强制化，并且“读书改变命运”，“努力就会有回报”，儒家文化等信条深入人心，大家都想往上面发展，助长了内卷。但如今经济和岗位并没有增加，反倒是硕士研究生爆表，本科生无处可去。社会上的饭碗依旧是那么几个，反而就业，待就业人数两年内凭空增加了800w，再加上下一年的1000w毕业生，将近2000w。而且还呈现逐年积累的趋势，该如何解决？无法解决，但不管所有人愿不愿意，这2000w迟早会被消化掉，怎么消化掉？不知道，反正能消化掉就是了。</p><p>&emsp;&emsp;因此，这次的“抄作业”显然大局已定。除此之外，这种政策也导致了就业人员，准就业人员，预就业人员（我自己），产生了眼高手低的通病。<br>&emsp;&emsp;为什么感觉毕业待遇一年不如一年？很简单，人多了，均摊就少了。“之前的毕业生能拿到那么多工资，那我也应该拿那么多。”虽然我也很想对别人这么说，我自己也会这样去想，但事实是，就是我们眼高手低，自己不配。我们毕业证书的含金量，在前人看来大学很不错，就是天之骄子，这也是为什么我们会从长辈那里得到赞誉的原因，但实际上是，我们这个时代毕业人数比他们那个时候增加了10倍，但社会的饭碗只增加了三倍，本科毕业，硕士毕业的含金量就被稀释掉了。整个社会上的硕士博士数量逐年增加，硕士博士学历的含金量也必然逐年被稀释，上面有政策有要求各单位扩招保障毕业生就业率，但企业准入门槛还是硕士没有变，怎么办？把硕士工资稀释掉呗，因此现在硕士的底薪在逐年减少，这样才能多养几个员工。<br>&emsp;&emsp;自己的底薪被稀释，对于近几年在默默努力，疯狂内卷的社会成员来说，大部分人们的努力，是绝对得不到他们预想中的回报的。劳资努力了好几年，不拿高薪，对得起自己这几年的努力吗？很遗憾，我们的努力，是时势所趋，并非时势所需。我们所学的高考知识，本科知识，考研考公的内容，可以说和今后的工作内容完美脱轨。企业给高薪资，涨薪资的条件是你有“工作”能力，而不是应试能力，因此内卷了却没有得到回报的人大有人在，郁郁寡欢的人大有人在，社会矛盾只会积重难返。但是不内卷躺平吗？只会更惨。</p><p>&emsp;&emsp;最后我们再来分析一下人口结构：<br>&emsp;&emsp;2002年15%的大学入学率，剩下的85%在干什么？<br>&emsp;&emsp;2020年55%的大学入学率，剩下的45%在干什么？<br>&emsp;&emsp;2002年产业结构主打的是轻工业，重工业与农业，2020年也还是轻工业，重工业与农业，产业结构没转型吗？转了，但不太多。那以前初高中毕业进厂干的活现在谁干了？答：本科生。以前本科生干的活现在谁干了？答：985，211毕业生。我们的学历都在提升，但所干的工作内容，可以说没有变化。相比2002，他们起码还有一技之长，虽然学历不高，但人家的技能是真能养活自己，而我们，什么都会，又什么都不会，大学打着培养融会贯通的高等人才的旗号，让我们去学遍自然科学，从这一刻开始，我们就开始了眼高手低的第一步，谁是融会贯通的高等人才？我融会贯通干什么？反正我肯定不是，我感觉和自然科学有关的课对我来说屁用没有。因此我的评价是：无用功盛行，浪费年轻人的生命，政策已经弊大于利了。到最后我们走进社会干的和先人干的没啥区别（因为向高新科技，制造业的产业转型太慢了），我们花了更长的时间在学海里兜兜转转还是回到了前人的起点，那我们做出的努力和耗费的生命还有什么意义？但我们的国度并不缺聪明人，可能我们人人都比马克思聪明，但让聪明人变傻是很简单的，我是不信马克思在经历了高考大学以后还能写出资本论，因为他得在大学毕业才步入社会，才有时间去思考。</p><p>&emsp;&emsp;由于我们的长辈基本没学历或者是普通本科，我们看到他们现在也还活得不错，小康水平，导致我们会产生本科毕业起码在十八线县城也能活得不错吧，我学历比我爸妈高，他们在十八线小县城，那我们应该可以在四线，五线城市过一个简朴富足的生活了吧！这就错了呀，大错特错，我们学历是高了，大家学历都高了，按宏观数据来说，现在的普通本科甚至远远对标不上当时的大专，放在2002年我们也还是进不去大学的那一批，随着大学扩招，本科扩招，研究生扩招，我们只不过空有知识，空有学历，但社会上的碗筷并没有多出多少。因此，我们学识远超我们的父母，我们的学历远超我们的父母，但我们能够得到的生活质量，可能还远远不如。<br>&emsp;&emsp;别嘲笑我们的老爸老妈没文化，放到1995年，我们也那样。</p><p>&emsp;&emsp;之后的几年还会时艰难的几年，Trump大选成功，贸易战经济战也在加速，甚至USA在重返月球，新一轮太空竞赛很难不开启。同时后疫情时代人们的精神状态，南北贫富差距进一步增大，低迷的生育率（东北三省生育率碾压韩国喜提世界倒数第一，黑龙江更是站在了世界之巅）。房地产的经济泡沫什么时候会爆，这些都没有定数。但和之前几年的飞速发展相比，之后的几年甚至十年应该会是最严峻的十年了。</p><p>&emsp;&emsp;这样第二个问题就解决完了。</p><p>&emsp;&emsp;至于第三个问题，算了，不利于团结的话不说了。<br>&emsp;&emsp;没事少看点国内自媒体，凡是唱主旋律的下面评论区官方都帮你关了，评论也替我们筛选好了，这都没点数吗，你能看到的，从来都是别人想要你看到的。</p><p>&emsp;&emsp;想要在这个社会上有立足之地，实力与能力在未来将成为决定性因素。<br>&emsp;&emsp;加油吧大伙，别把挫折看的那么重，整点真本事出来，少往心里放点事，乐观面对每一天，比啥都强。<br>&emsp;&emsp;以上内容仅取自我的个人视角，有问题不去正视才是最蠢的，听之任之，是对历史与文明的不敬，更对不起世世代代的努力<br>&emsp;&emsp;祝伟大的祖国繁荣昌盛</p>]]></content>
      
      
      <categories>
          
          <category> 社会现象分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 就业难 扩招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客设计初衷</title>
      <link href="/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/10.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><p>&emsp;&emsp;今天是2022年11月21日，也是本人在博客网站几乎完成了所有的基础构建，开服的第一天。关于我为什么要创建博客，就是想充分的利用闲暇时间提升一下个人能力与素养，相当于写写日记，记录一下平时的所看所学所想，整理我在本科，研究生生涯的学习思路与内容。在这个经济低迷学历贬值的时代，广泛的涉猎，融会贯通，精于一处变得越来越重要。这是一个靠能力与学历的时代，是一个内卷内耗的时代，希望各位都能乐观豁达地面对挫折，没有什么过不去的坎，不要成为自己的敌人。同时我也希望自己的学习目的更多地从兴趣爱好出发，而不是迫于生计的压力给自己制定目标。在学习的过程中获得成就感，见证自己能力的增长也是一件很有意义的事情。</p><p>&emsp;&emsp;我就是个普通人，按照强化学习中的说法，反复学习就是训练自己的神经网络，人的价值也直接取决于自己网络训练的好坏。有人生来就在罗马，有人早早便没有了努力的必要，但作为芸芸众生的一份子，强者能区别于弱者便是靠着个人能力与精神上的强大。我想将自己的学习，生活中的历程与踩过的坑分享出来，帮助同样是想要学习一些热门知识并且想要交流沟通的人。相信已经学四年的你一定知道能否得到帮助的重要性，在本网站中，我会先将学习的内容分成以下几个我目前在学的大类，在这些类中我会分享我在学习中所看过的好的视频，通俗易懂的CSDN，知乎，简书以及我个人的梳理与理解。目前几个大类应该是：C++编程（QT），SLAM，计网与操作系统，硬软件茶谈（比如软硬件，git,服务器的使用，linux手册等常识性知识）。</p><p>&emsp;&emsp;搭建整个博客耗费了两天时间，保研以后空出的时间多了起来，我也在广泛学习一些网络技术以及编程技术，博客就是主要开发的项目之一，我也推荐大家记录一些生活中的故事，在现如今如此快节奏且的生活中给自己留一点空间，反思提升自己显得格外珍贵。更新的话大致每周一篇。</p><p>&emsp;&emsp;博客使用方法：手机端的适配还没时间开发，不过也仅仅是将就能看的程度，网页头部栏目列表中的音乐和电影都是可用的，但仅仅添加了我自己喜欢的部分。标签和分类栏可以查找文章与文章类型，可以在留言处给我留言写评论（评论要账号登录）。此外在右下角可以切换白天黑夜模式，简体繁体。</p><div style="position: relative; padding: 30% 45%;"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=647947332&bvid=BV1fe4y1p7Co&cid=898707876&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线程</title>
      <link href="/C-%E7%BA%BF%E7%A8%8B/"/>
      <url>/C-%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/22.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><p>QT的线程：引入&lt; QThread &gt; 两种用法：</p><p>第一种：<br>&emsp;&emsp;实例化类：thread = new Thread ;<br>&emsp;&emsp;启动线程：&lt; QThread &gt;类中带有虚函数run()，把需要线程处理的函数放在run()中重新实现。即在Thread.h与Thread.cpp文件中重写run()；<br>&emsp;&emsp;启动线程: thread-&gt;start()打开新的线程，就会自动调用run()函数。<br>&emsp;&emsp;关闭线程：thread.quit();thread.wait();<br><img src="/img/thread1.png" alt=""><br>第二种：<br>&emsp;&emsp;该方法更为灵活，方法一将要实现的内容放在run()函数中，这就造成了一定的局限性。新方法将重新定义一个新的class，将该类与实例化的thread绑定(相当于方法一中run()中的内容用新的class重写了)，这样启动thread()就会创建新的线程。<br>&emsp;&emsp;实例化类：thread = new QThread ;（不用创建.h .cpp来重写run()了）<br>&emsp;&emsp;实例化类：myT = new myObject; 在类文件(.h .cpp)中重写要实现的函数myT-&gt;myTimeout()。<br>&emsp;&emsp;将该类与线程绑定：myT-&gt;moveToThread(thread);<br>&emsp;&emsp;启动线程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;start();</span><br><span class="line">emit <span class="title function_">startThread</span><span class="params">()</span>;</span><br><span class="line">connect(this,&amp;myWidget::startThread,myT,&amp;myObject::myTimeout)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;关闭线程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.quit();</span><br><span class="line">thread.wait();</span><br></pre></td></tr></table></figure><br><img src="/img/thread2.png" alt=""><br>&emsp;&emsp;不过要注意，该方法启动线程：thread-&gt;start()，只启动了线程，但没有启动线程处理函数。如果在这之后添加myT-&gt;myTimeout()；来主动调用线程函数也是不可以的，这样会导致线程函数和主线程在同一线程。<br>&emsp;&emsp;(用qDebug&lt;&lt; QThread::currentThread();可以查看当前线程号)<br>&emsp;&emsp;这时需要在Widget构造函数中connect(this,&amp;myWidget::startThread,myT,&amp;myObject::myTimeout)来连接线程函数。<br>&emsp;&emsp;调用thread.quit()；thread.wait();后线程不会立即关闭，而是等待线程函数处理完毕后才会关闭线程。<br>&emsp;&emsp;connect()函数的第五个参数，是和多线程有关的，默认多线程，槽函数所在线程与接收者一样，即myT与&amp;myObject::myTimeout一个线程。这也解释了方法二为什么要用connect()启动线程函数，因为connect()有主线程，子线程之分，当代码中出现绑定线程的操作：myT-&gt;moveToThread(thread)，则connect()就会把myT与&amp;myObject::myTimeout放到子线程执行。</p><p>[线程详细教学]<a href="https://www.bilibili.com/video/BV1XW411x7NU?p=79&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1XW411x7NU?p=79&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++规范</title>
      <link href="/C-%E8%A7%84%E8%8C%83/"/>
      <url>/C-%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="h文件书写（侯捷第二讲）"><a href="#h文件书写（侯捷第二讲）" class="headerlink" title=".h文件书写（侯捷第二讲）"></a>.h文件书写（侯捷第二讲）</h1><h2 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h2><p>include&lt;    .h&gt;包含的是库文件。<br>include “   .h”包含的是自己写的文件  </p><h2 id="关于全局变量"><a href="#关于全局变量" class="headerlink" title="关于全局变量"></a>关于全局变量</h2><p>&emsp;&emsp;头文件可以放什么？   </p><ol><li>struct/union 的声明,C++可以在头文件的 struct/class 内部随即给出方法的实现</li><li>typedef 声明</li><li>函数，类声明</li><li>extern 变量声明</li><li>一些const常量<br>&emsp;&emsp;绝对不能放   </li><li>全局定义变量（声明都不要有，全局变量声明就是定义）</li><li>给出函数的定义（可以有声明，若非要在.h文件给出定义则需要结合extern预防重定义）</li></ol><font color=YellowGreen>a.h</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font color=YellowGreen>b.cpp</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font color=YellowGreen>a.cpp</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码会有函数重定义报错，把a.h的函数声明留下，把定义搬到a.cpp就好了。</p><p>&emsp;&emsp;否则重定义教你做人。</p><p>&emsp;&emsp;C语言在头文件中包含全局变量有三种形式：</p><ol><li>在头文件中声明(extern)一个全局变量，在一个C文件中定义全局变量，然后在所有的引用了这个头文件的C文件里都可以使用该全局变量值。<br>如在main.c定义 int a = 3;<br>然后定义一个main.h,那么所有引用main.h的c文件中，均可以访问a并更改其值。</li><li>在头文件中定义一个静态全局变量。那么所有引用该头文件的C文件，均拥有一个作用域在本文件范围内的同名静态全局变量。不同文件中的该变量虽然同名，但却是不同的变量。<br>比如在a.h中定义<br>static int a = 3;<br>那么在a.c中引用a.h，并将a值修改为4。<br>在b.c中也引用a.h,不对a值做修改，打印a值，仍为3， 不会因为a.c中的修改而改变值</li><li>在头文件中定义全局变量。该头文件仅可以被一个C文件引用一次。<br>比如a.h中定义<br>int a = 3;<br>在a.c中可以引用a.h，并对a进行访问和修改。<br>如果在同项目下有b.c引用了a.h，编译器在链接时会报同名全局变量的错误，导致编译失败。</li></ol><h2 id="头文件中的防卫式声明"><a href="#头文件中的防卫式声明" class="headerlink" title="头文件中的防卫式声明"></a>头文件中的防卫式声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__  </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line">    。。。</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">```   </span><br><span class="line">&amp;emsp;&amp;emsp;一般来说，在写c++代码的时候，每个cpp都会对应一个头文件（.h文件），当然也可能由于文件内容过于简单，没有cpp文件，只有头文件。我们的头文件可能是专门为某个cpp文件写的，也可能是公共的，为多个cpp文件服务。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;防卫三段式只能保证同一个头文件不会在同一个编译单元中被重复展开，比如你在一个.cpp中<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span>后又#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span>，而你在b.h中已经#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span>了，这样三段式可以保证a.h只被编译一次而不是两次。但方位头文件可保护不了你在多个编译单元中重复定义相同的符号（重定义）。   </span></span><br><span class="line">&amp;emsp;&amp;emsp;只要头文件有了上面的三行代码，你就可以在任意用到该头文件的地方include该头文件。如果是第一次include，由于没有定义__HEAD__,因此就会首次定义，当第二次include该头文件时，由于已经定义了__HEAD__，所以就直接跳过了，不会造成重复声明。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;建议：为了不必要的麻烦，最好在每个头文件上加上这样的防卫式声明。即使现在你只有一个cpp使用该头文件，万一之后再有别的cpp使用该头文件嘞。   </span><br><span class="line">PS：防卫式声明一般这样写：__(<span class="number">2</span>个下划线，不是<span class="number">1</span>个)+头文件名的大写（不包括.h）+__(<span class="number">2</span>个下划线，不是<span class="number">1</span>个)，例如头文件为head.h时，就使用__HEAD__，这是为了防止重复。     </span><br><span class="line">&amp;emsp;&amp;emsp;补充：如果要在多个源文件之间共享全局变量（不要在头文件中定义全局变量，比如<span class="type">int</span> a=<span class="number">5</span>;但可以<span class="type">const</span> <span class="type">int</span> a=<span class="number">5</span>,定义<span class="keyword">struct</span> 等），你需要在每个源文件中<span class="keyword">extern</span>声明该全局变量，然后在一个源文件中进行定义即可,其他使用外部链接声明即可，不需要<span class="meta">#<span class="keyword">include</span>定义头文件了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类的写法</span><br><span class="line">## 构造函数标准写法</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> complex</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);<span class="comment">//有分号，是声明；这里传的是引用，const是说不能改引用的内容。</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> <span class="title">const</span><span class="params">(<span class="keyword">return</span> re;)</span><span class="comment">//没分号，是定义。class里的函数分为会改变数据的，和不会改变数据的，不会改变数据内容，加const。</span></span></span><br><span class="line"><span class="function">    <span class="type">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="title">const</span><span class="params">(<span class="keyword">return</span> im;)</span><span class="comment">//没分号，是定义</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">    double re, im;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> complex&amp; __doapl (complex*, <span class="type">const</span> complex&amp;)</span><br><span class="line">&#125; </span><br><span class="line">```     </span><br><span class="line">其中的构造函数等同于</span><br><span class="line">```c++</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">    &#123;re = r; im = i&#125;</span><br><span class="line">```    </span><br><span class="line">构造函数的使用：  </span><br><span class="line">```c</span><br><span class="line">    complex <span class="built_in">c1</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    complex c2;</span><br><span class="line">    complex* p = <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">4</span>);</span><br><span class="line">```     </span><br><span class="line">注意类里面没有指针，所以类里面不需要析构函数。</span><br><span class="line">## 解析complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);    </span><br><span class="line">&amp;emsp;&amp;emsp;+=是二元操作符，有二元操作数，左或右，编译器看到这一行会把二元操作符作用在左边的操作数上，如果左边的操作数对此二元操作数有定义，编译器就会去找重载函数。    </span><br><span class="line">```c++</span><br><span class="line">complex&amp; complex::<span class="keyword">operator</span> += (<span class="keyword">this</span>,<span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex&amp; __doapl(complex* ths, <span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    ths-&gt;re += r.<span class="built_in">real</span>();</span><br><span class="line">    ths-&gt;im +=r.<span class="built_in">imag</span>();</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数名是operator +=,函数调用后返回一个别名，这里定义一个complex c1(2,1);complex c2(3,4);c1 += c2;最后返回给c1。任何成员函数都有一个this point,谁调用成员函数这个this就指向谁。注意<em>this是用complex&amp;接收的，而与 </em>this相同类型的临时变量value不能用complex&amp;接收，因为value会在函数执行完毕后被释放掉。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>&emsp;&emsp;需要注意的是上面返回了一个别名。但如果最终的重载运算结果不存储在二元操作数之中，需要临时存储，比如7+c1,那么重载运算就要放到class body之外，可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">complex <span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; c1, <span class="type">const</span> complex&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(c1.<span class="built_in">real</span>()+c2.<span class="built_in">real</span>(), c1.imag+c2.<span class="built_in">imag</span>())</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">&amp;emsp;&amp;emsp;这里用到了临时对象<span class="built_in">typename</span>()，省掉了命名（这也不是构造函数）。其中<span class="keyword">typename</span>也可以是<span class="type">int</span>,<span class="type">double</span>等。这行代码执行完毕后空间被释放掉。</span><br><span class="line">##<span class="meta"># cout&lt;&lt; ；原理  </span></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">complex <span class="title">conj</span> <span class="params">(<span class="type">const</span> complex&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (x.<span class="built_in">real</span>(), x,<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os,<span class="type">const</span> complex&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&#x27;(&#x27;</span>&lt;&lt; x.<span class="built_in">real</span>()&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;x.<span class="built_in">imag</span>()&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;返回ostream&amp;是为了应对cout&lt;&lt; c1 &lt;&lt; <span class="built_in">conj</span>(c2);的情况。</span><br><span class="line">&amp;emsp;&amp;emsp;为什么<span class="built_in">conj</span>()返回的临时对象可以被<span class="keyword">operator</span> &lt;&lt;的别名接收？<span class="built_in">conj</span>()运行完不是清理内存了吗？这是因为c++的内存清理机制是惰性的，它并不会在此函数调用完立即清除其占用的内存，<span class="keyword">return</span>的临时对象编译器会保留一下，此时这个临时对象是有实际的地址，因此可以传给<span class="keyword">operator</span> &lt;&lt;函数中的别名类型，执行到下一行，也就是cout结束后才把<span class="built_in">conj</span>()之中临时对象的内存释放掉。</span><br><span class="line"># 类中的<span class="keyword">this</span></span><br><span class="line">上个大类中</span><br><span class="line">```c++</span><br><span class="line">complex c1,c2,c3;</span><br><span class="line">cout&lt;&lt;c1.<span class="built_in">real</span>();</span><br><span class="line">cout&lt;&lt;c2.<span class="built_in">real</span>();</span><br></pre></td></tr></table></figure><br>用c语言这么写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">complex c1,c2,c3;</span><br><span class="line">cout&lt;&lt; complex::<span class="built_in">real</span>(&amp;c1);</span><br><span class="line">cout&lt;&lt; complex::<span class="built_in">real</span>(&amp;c2);</span><br></pre></td></tr></table></figure><br>这个real函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;re; &#125;<span class="comment">//this-&gt;可写可不写，编译器会帮忙补齐的。</span></span><br><span class="line">provate:</span><br><span class="line">    <span class="type">double</span> re, im;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;因此在调用类中的函数时，编译器会把this指针指向调用函数的对象。</p><h1 id="类中的静态变量"><a href="#类中的静态变量" class="headerlink" title="类中的静态变量"></a>类中的静态变量</h1><p>&emsp;&emsp;创建一个银行账户的大类，创建的每个对象都是存款人，这些存款人在银行中有相同的利率。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">double</span> m_rate;<span class="comment">//声明</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span>   </span>&#123;m_rate = x&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Account::m_rate = <span class="number">8.0</span>;<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account::<span class="built_in">set_rate</span>(<span class="number">5.0</span>);</span><br><span class="line">    Account a;</span><br><span class="line">    a.<span class="built_in">set_rate</span>(<span class="number">7.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类中的静态成员变量"><a href="#类中的静态成员变量" class="headerlink" title="类中的静态成员变量"></a>类中的静态成员变量</h2><p>&emsp;&emsp;类中的静态成员变量与类中的成员变量不同，无论创建多少个类的对象，静态成员都只有一份</p><h2 id="类中的静态函数"><a href="#类中的静态函数" class="headerlink" title="类中的静态函数"></a>类中的静态函数</h2><p>&emsp;&emsp;静态函数和一般的成员函数一样也只有一份。成员函数都是默认有this指针的，而静态成员函数没有this指针，因此它只能操作静态成员变量。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>&emsp;&emsp;也就是说你没有创建任何对象时，你也可以使用静态成员变量和静态函数，比如银行现在没有人来存钱，就不用创建对象，可以通过设置静态变量来先设定利率。这样以后即使10000个人创建对象，你也可以通过调整静态变量实时更改利率。如果把利率放在成员变量中，挨个更改每个已创建对象的利率是一个极其麻烦的过程！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写出良好标准的代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++笔记-3</title>
      <link href="/C-%E8%B8%A9%E5%9D%913/"/>
      <url>/C-%E8%B8%A9%E5%9D%913/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/19.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><h1 id="C-C-中-volatile-关键字详解"><a href="#C-C-中-volatile-关键字详解" class="headerlink" title="C/C++ 中 volatile 关键字详解"></a><font color=DeepSkyBlue size=5 face="黑体">C/C++ 中 volatile 关键字详解</font></h1><p>&emsp;&emsp;volatile用于随时可能发生变化的变量，避免因为编译器优化程序而出错。编译器在多次访问一个变量时，并不会一直通过寻址访问，而是访问寄存器中已经存好的副本（因为快），这时如果出现一些编译器预料之外的改动就会出错。如内嵌汇编操纵栈”、多线程并发访问共享变量时，一个线程改变了变量的值，其他线程可能看不见改动。因此volatile 的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，如下：</p><p>&emsp;&emsp;链接：<a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">https://www.runoob.com/w3cnote/c-volatile-keyword.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, a);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 下面汇编语句的作用就是改变内存中 i 的值</span></span><br><span class="line">    <span class="comment">// 但是又不让编译器知道</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov dword ptr [ebp<span class="number">-4</span>], <span class="number">20</span>h</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//release运行结果：</span></span><br><span class="line"><span class="comment">//i = 10</span></span><br><span class="line"><span class="comment">//i = 10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加了关键字后每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读到寄存器（或高速缓存）中的数据放在b中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。加入volatile int i = 10;第二次i=32,符合预期</p><h1 id="C-C-中-左值、右值、右值引用"><a href="#C-C-中-左值、右值、右值引用" class="headerlink" title="C/C++ 中 左值、右值、右值引用"></a><font color=DeepSkyBlue size=5 face="黑体">C/C++ 中 左值、右值、右值引用</font></h1><p>&emsp;&emsp;链接<a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Intvec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Intvec</span><span class="params">(<span class="type">size_t</span> num = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        : m_size(num), m_data(new int[m_size])</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Intvec</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;destructor&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_data) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">            m_data = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Intvec</span>(<span class="type">const</span> Intvec&amp; other)</span><br><span class="line">        : <span class="built_in">m_size</span>(other.m_size), <span class="built_in">m_data</span>(<span class="keyword">new</span> <span class="type">int</span>[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;copy constructor&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span><br><span class="line">            m_data[i] = other.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intvec&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Intvec&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;copy assignment operator&quot;</span>);</span><br><span class="line">        <span class="function">Intvec <span class="title">tmp</span><span class="params">(other)</span></span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(m_size, tmp.m_size);</span><br><span class="line">        std::<span class="built_in">swap</span>(m_data, tmp.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> m_size;</span><br><span class="line">    <span class="type">int</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Intvec v2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;assigning rvalue...\n&quot;</span>;</span><br><span class="line">v2 = <span class="built_in">Intvec</span>(<span class="number">33</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ended assigning rvalue...\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;右值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Intvec&amp; <span class="keyword">operator</span>=(Intvec&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;move assignment operator&quot;</span>);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_size, other.m_size);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_data, other.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Intvec&amp; operator=(const Intvec&amp; other)如果不加const,那么右值Intev(33)传不进去，因为引用是左值，但右值和常量左值可以绑定。去掉const会报错。不用右值引用的方法是把传进来的右值赋值给左值，再swap()。</li><li>在C++11之后，swap()中可以传右值引用了。</li><li>在不能用右值引用的情况下想把右值传进函数Intvec&amp; operator=(const Intvec&amp; other)，只能在传参处加const，利用常量左值可以绑定右值把右值传进来，然后在按照右值做一个左值副本传进swap()。为什么不能直接向swap()内传对象other?因为swap()内不能传const对象，多以必须建一个副本。可见C++11引入右值引用就完全解决了这个问题。</li></ol><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a><font color=DeepSkyBlue size=5 face="黑体">std::move()</font></h1><p>&emsp;&emsp;链接：<a href="https://blog.csdn.net/p942005405/article/details/84644069">https://blog.csdn.net/p942005405/article/details/84644069</a></p><p>&emsp;&emsp;在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。<br>&emsp;&emsp;从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);</p><ol><li><p>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 因此在push_back()中定义了通过传入右值来执行移动构造函数来节省内存,通过std::move创建对象的右值，可以避免不必要的拷贝操作。</p></li><li><p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。</p></li><li><p>对于内置类型（如 int、float、double 等），它们的复制和移动本质上是相同的，因为它们的值都是在栈上分配的，没有动态资源需要管理。因此，即使使用 std::move() 将其转换为右值引用，实际上也只是将其视为右值，但不会导致任何性能上的提升。</p></li><li><p>性能提升通常是与管理动态资源相关的。例如，在使用自定义类型、STL容器或者智能指针等情况下，它们通常会涉及动态内存的分配和释放，以及资源的所有权转移。在这种情况下，使用 std::move() 可以显著提升性能，因为移动操作只是简单地将资源的所有权从一个对象转移到另一个对象，而不需要进行深层的复制操作。这样可以避免额外的内存分配和释放，从而提高程序的性能。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;After copy, str is&quot;</span>&lt;&lt;str;<span class="comment">//&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;v[<span class="number">0</span>];</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;After move,str is&quot;</span>&lt;&lt;str;<span class="comment">//&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="emplace-back-和push-back"><a href="#emplace-back-和push-back" class="headerlink" title="emplace_back()和push_back()"></a><font color=DeepSkyBlue size=5 face="黑体">emplace_back()和push_back()</font></h1><p>&emsp;&emsp;链接：<a href="https://zhuanlan.zhihu.com/p/213853588">https://zhuanlan.zhihu.com/p/213853588</a><br>&emsp;&emsp;二者的主要区别在于对于存放右值对象时的不同。C++11之后，二者仅在一种情况下存在区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) : _age(age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;二者唯一的区别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    vector&lt;Person&gt; person;</span><br><span class="line"></span><br><span class="line">    person.<span class="built_in">emplace_back</span>(<span class="number">1</span>); <span class="comment">//Construct a person.1</span></span><br><span class="line"></span><br><span class="line">    person.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//Construct a person.1, Move-Construct1（移动构造函数）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上述情况中emplace_back显然更高效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;剩下的情况：</p><ol><li>向vector中放入左值（对象）：person.push_back(p);person.emplace_back(p);都是调用构造函数，拷贝构造函数。</li><li>向vector中放入右值（临时对象）person.push_back(Person(1));person.emplace_back(Person(1));都是调用构造函数，移动构造函数。</li><li>向vector中放入右值（临时对象）person.push_back(std::move(p));person.emplace_back(std::move(p));和上面一样，都是调用构造函数，移动构造函数，因为都是传了一个右值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    vector&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">Person</span>(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    person.<span class="built_in">emplace_back</span>(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面例子中，注意加入第二个对象后，vector会扩容，原先就有的p是移动构造到更大的vector中的。将上面例子中emplace_back换为push_back结果是一样的，这是因为C++11后，push_back()和emplace_back()都对传入右值做了设计，唯一有区别的地方就是直接传入对象参数时emplace_back就地构造，而不是像push_back要构造再移动构造。剩余情况而是都是要先构造，再复制/移动构造。<br>&emsp;&emsp;除此之外，如果设计的类中没有设计移动构造，那么原本要移动构造可以向下兼容成拷贝构造。</p><p>这里提供一个调试的demo:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClassTwoPara</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BaseClassTwoPara</span>(<span class="type">int</span> a)</span><br><span class="line">        &#123;</span><br><span class="line">        m_a = a;</span><br><span class="line">        m_b = <span class="number">999</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct &quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BaseClassTwoPara</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            m_a = a;</span><br><span class="line">            m_b = b;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;construct &quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BaseClassTwoPara</span>(<span class="type">const</span> BaseClassTwoPara &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            m_a = rhs.m_a;</span><br><span class="line">            m_b = rhs.m_b;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;copy construct &quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BaseClassTwoPara</span>(<span class="type">const</span> BaseClassTwoPara &amp;&amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            m_a = rhs.m_a;</span><br><span class="line">            m_b = rhs.m_b;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;move copy construct &quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">BaseClassTwoPara</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;delete &quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> m_a, m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_TwoPara_push_back_cp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;BaseClassTwoPara&gt; vl;</span><br><span class="line">    <span class="function">BaseClassTwoPara <span class="title">p</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    vl.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_TwoPara_push_back_cp&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针，踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++笔记-1</title>
      <link href="/C-%E8%B8%A9%E5%9D%91/"/>
      <url>/C-%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/19.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><!-- timeline 2022-12-5 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><h1 id="关于常量指针与指针常量"><a href="#关于常量指针与指针常量" class="headerlink" title="关于常量指针与指针常量"></a><font color=DeepSkyBlue size=5 face="黑体">关于常量指针与指针常量</font></h1><pre><code>const int *p=&amp;a ; </code></pre><p>const 修饰的是取 <em> 的操作，因此取星操作不能改变，就是 </em>p的值(p所指的内容)不可改变 ，但指针的方向可以改变。<br><img src="/img/5.png" alt="">  </p><pre><code>int * const p = &amp;a ; </code></pre><p>const修饰的是p这个指针，因此这个指针的指向固定了，但是指针所指的内容可以改变。<br><img src="/img/4.png" alt="">  </p><pre><code>char *p=&quot;hello&quot;;p=&quot;aa&quot;;//报错</code></pre><p>这种方法初始化的字符串是常量字符串，不能修改，相当于const char *p=”hello”。</p><pre><code>char p[]=&quot;hello&quot;;p[0]=&#39;a&#39;;cout&lt;&lt;p&lt;&lt;endl;</code></pre><p>这是变量，可以修改。</p><pre><code>char *p=new char[6];p=&quot;hello&quot;;</code></pre><p>下面是应用举例：</p><pre><code>char* test(char* x) &#123;x[2] = &#39;\0&#39;;//标记点return x;&#125;int main() &#123;    char* x = (char*)&quot;svgc&quot;;    cout &lt;&lt; test(x);&#125;</code></pre><p>会报错，因为传入的char*地址指向了一个字符串常量</p><pre><code>char* test(char* x) &#123;    x[2] = &#39;\0&#39;;    return x;&#125;int main() &#123;    char x[] = &quot;svgc&quot;;    cout &lt;&lt; test(x);&#125;</code></pre><p>这个就不会报错<br><!-- endtimeline --></p><!-- timeline 2022-12-24 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><h1 id="指针与别名接收栈空间返回值"><a href="#指针与别名接收栈空间返回值" class="headerlink" title="指针与别名接收栈空间返回值"></a>指针与别名接收栈空间返回值</h1><pre><code>int test01()&#123;    int a=10;    return a;&#125;int main()&#123;    int &amp;ref = test01();    cout&lt;&lt;&quot;ref = &quot;&lt;&lt; ref &lt;&lt; endl;    cout&lt;&lt;&quot;ref = &quot;&lt;&lt; ref &lt;&lt; endl;&#125;</code></pre><p>输出结果： ref = 10<br>          ref = 2425255</p><p>原因，拿别名指向返回值，但test01()执行完后，该返回值所在空间被释放了，编译器会默认保留返回值一次。<br>同理：</p><pre><code>int test01()&#123;    int a=10;    return &amp;a ;&#125;int main()&#123;    int *ref = test01();    cout&lt;&lt;&quot;ref = &quot;&lt;&lt; *ref &lt;&lt; endl;    cout&lt;&lt;&quot;ref = &quot;&lt;&lt; *ref &lt;&lt; endl;&#125;</code></pre><p>输出结果： ref = 10<br>          ref = 2425255<br>也是一个原因。其本质都是指针指向了一个被释放的栈空间而编译器只保留了一次。<br><!-- endtimeline --></p><!-- timeline 2023-5-1 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><h1 id="引用和指针区别"><a href="#引用和指针区别" class="headerlink" title="引用和指针区别"></a>引用和指针区别</h1><h2 id="定义上的区别"><a href="#定义上的区别" class="headerlink" title="定义上的区别"></a>定义上的区别</h2><p>指针和引用主要有以下区别：</p><ol><li>引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。</li><li>引用初始化后不能被改变，指针可以改变所指的对象。</li><li>不存在指向空值的引用，但是存在指向空值的指针。<br>注意：引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能引发错误。所以使用时一定要小心谨慎。</li></ol><p>&emsp;&emsp;从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。</p><p>&emsp;&emsp;而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。</p><p>&emsp;&emsp;指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。 在程序编译的时候，将指针和引⽤添加到符号表中。</p><ol><li>指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有 const 和⾮ const 区别，甚⾄可以为空， sizeof 指针得到的是指针类型的⼤⼩。</li><li>⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将”引用变量名-引⽤对象的地址”添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。<br>具体举例：<a href="https://zhuanlan.zhihu.com/p/140966943">https://zhuanlan.zhihu.com/p/140966943</a><h2 id="传参上的使用"><a href="#传参上的使用" class="headerlink" title="传参上的使用"></a>传参上的使用</h2>&emsp;&emsp;在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：</li></ol><p>&emsp;&emsp;指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针指向的地址值不会变，但地址的内容可能会变，调用的函数对传入指针指向的地址做备份，可以改变该地址内存的内容，但不能影响实参指针指向的地址）<br>&emsp;&emsp;而在引用传递过程中， 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（传进被调函数的东西是变量别名，但备份值传递的值是实参的地址！传递指针中传入被调函数的东西是指针指向的地址，备份的也是指针指向的地址）。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。<br>&emsp;&emsp;引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，被调函数只是复制了指针指向的地址，并不能改变实参指向的地址。引用传递的实参指的是变量本身，指针传递的实参指的是指针指向的地址，因此引用传递可以改变实参；指针传递不能改变实参（指针指向的地址），但能改变这个地址对应的内容。  </p><h2 id="下面是代码举例："><a href="#下面是代码举例：" class="headerlink" title="下面是代码举例："></a>下面是代码举例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change1</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;值传递--函数操作地址&quot;</span>&lt;&lt;&amp;n&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//显示的是拷贝的地址而不是源地址 </span></span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change2</span><span class="params">(<span class="type">int</span> &amp; n)</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;引用传递--函数操作地址&quot;</span>&lt;&lt;&amp;n&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change3</span><span class="params">(<span class="type">int</span> *n)</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;指针传递--函数操作地址 &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    *n=*n+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span>     <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;实参的地址&quot;</span>&lt;&lt;&amp;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    change1(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;after change1() n=&quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    change2(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;after change2() n=&quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    change3(&amp;n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;after change3() n=&quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了进一步加深大家对指针和引用的区别，下面我从编译的角度来阐述它们之间的区别：</p><p>&emsp;&emsp;程序在编译时分别将指 针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><h2 id="最后，总结一下指针和引用的相同点和不同点："><a href="#最后，总结一下指针和引用的相同点和不同点：" class="headerlink" title="最后，总结一下指针和引用的相同点和不同点："></a>最后，总结一下指针和引用的相同点和不同点：</h2><p>★相同点：</p><ol><li><p>都是地址的概念；</p></li><li><p>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</p></li></ol><p>★不同点：</p><ol><li><p>指针是一个实体，而引用仅是个别名；</p></li><li><p>引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</p></li><li><p>引用没有const，指针有const，const的指针不可变；</p></li><li><p>引用不能为空，指针可以为空；</p></li><li><p>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p></li><li><p>指针和引用的自增(++)运算意义不一样；</p></li><li><p>引用是类型安全的，而指针不是,（引用比指针多了类型检查）</p><!-- endtimeline --></li></ol><!-- timeline 2023-5-7 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><h1 id="CMake编译源文件"><a href="#CMake编译源文件" class="headerlink" title="CMake编译源文件"></a><font color=red size=5 face="黑体">CMake编译源文件</font></h1><p>下面是利用CMake编译open62541库：<br><a href="https://blog.csdn.net/qq_54227351/article/details/129380793?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2">https://blog.csdn.net/qq_54227351/article/details/129380793?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2</a></p><p>&emsp;&emsp;在软件开发中，库（或动态链接库）是编译好的二进制代码的集合，其中包含可重用的函数和类。当您链接一个库时，编译器会将库中的函数和类与您的源代码一起链接到一个可执行文件中。在这个可执行文件运行时，库中的函数和类就可以被调用和使用了。<br>&emsp;&emsp;在Windows系统中，库文件通常有两种扩展名：.lib和.dll。.lib文件是静态库，其中包含了库的二进制代码，链接时会将代码静态地链接到您的应用程序中。.dll文件是动态链接库，其中包含了库的二进制代码，但是在链接时不会将代码静态地链接到您的应用程序中，而是在运行时动态地加载和链接库。<br>&emsp;&emsp;在QT项目中，当您通过pro文件中的LIBS选项将库文件链接到您的项目中时，编译器会将库文件中的二进制代码与您的源代码链接到一起。因此，您不需要在源文件中包含库文件中的源代码文件（.c文件），因为这些文件已经被编译成了二进制代码，并且在链接时被链接到您的源代码中。  </p><p>QT导入库可能出现的问题：<br><a href="https://blog.csdn.net/yqahx/article/details/120012706">https://blog.csdn.net/yqahx/article/details/120012706</a><br><!-- endtimeline --></p><hr><h1 id="关于-char-char-string"><a href="#关于-char-char-string" class="headerlink" title="关于 char* , char[], string"></a>关于 char* , char[], string</h1><h2 id="char-与char"><a href="#char-与char" class="headerlink" title="char*与char[]"></a>char*与char[]</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p[] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上第一行代码，const char<em> p = “12345”; 是在数据段（静态存储区）开了一块空间存”12345”,p指向的是静态区中的内容，不能通过修改</em>p来改变其内容。C++11编译器编译这行代码时，甚至不加const也能通过编译。<br>&emsp;&emsp;第二行代码，在数据段（静态存储区）开了一块空间存”12345”,然后编译器调用strcp()函数将其复制到函数栈中，随后释放掉数据段中的内容。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>&emsp;&emsp;string在数据结构中被称为串，通过观察其STL给出的接口函数，发现其很类似于动态数组（vector），那么用string和用vector&lt; char&gt;不是差不多嘛？<br>&emsp;&emsp;其实并不是的，首先是两者被定义后被分配的位置。vector的底层是malloc()分配的地址，因此一定是被放在堆中。<br>&emsp;&emsp;string的空间分配比较特殊，拿gcc来说，当定义的string s小于15个字符时，会被分配到栈中，而在15个字符以上时，就会被重新复制分配到堆中。<br>&emsp;&emsp;二者的共同点是，当不断push_back超出最先给定的容量时，编译器会再次找到一块是原来二倍大的内存，将原有内容深拷贝进去。<br>&emsp;&emsp;定义字符串时，C语言char str[] = “adadadad”;或char str[ 10 ];用C++的string时，只需要string str;相比C语言的字符串不需要提前指明str的具体大小！同时string的内部接口与STL的vector几乎一模一样，包括算法，迭代器的使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//string转char*</span></span><br><span class="line">string strOutput = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pszOutput = strOutput.<span class="built_in">c_str</span>();<span class="comment">//.c_str()返回的是const char*，因此不能直接给到char[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string转char[]</span></span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> p[<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;str.<span class="built_in">length</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = str[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">p[i] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//这一步比较重要</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char*,char[]转string</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pszName = <span class="string">&quot;liitdar&quot;</span>;</span><br><span class="line"><span class="type">char</span> pszCamp[] = <span class="string">&quot;alliance&quot;</span>;</span><br><span class="line"> </span><br><span class="line">string strName;</span><br><span class="line">string strCamp;</span><br><span class="line"> </span><br><span class="line">strName = pszName;</span><br><span class="line">strCamp = pszCamp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此说白了，string类似于char<em>，但string类只做了string = 的重载，因此string strName = pszName可以直接等于char</em>，但string转char<em> 时就会发现实际上string s的只是一个类似char</em> 的迭代器指针，因此还要用c_str()转为const char*。</p><ol><li>string 的反向迭代器reverse_iterator，是通过从后向前++来进行遍历的,rbegin()到rend()。</li><li>可以用vector&lt; string&gt;实现二维字符数组</li><li>string .find()找到了返回首字符位置，找不到返回-1。</li><li>stoi(const std::string&amp; str, std::size_t<em> pos = nullptr, int base = 10)可以把string转化为int，这里传一个char</em>效果也是一样的。</li><li>stoll()，string转long long 类型</li></ol><hr><h1 id="仿函数-（leetcode347）"><a href="#仿函数-（leetcode347）" class="headerlink" title="仿函数 （leetcode347）"></a>仿函数 （leetcode347）</h1><p>&emsp;&emsp;仿函数是定义了一个含有operator()成员函数的对象，可以视为一个一般的函数，只不过这个函数功能是在一个类中的运算符operator()中实现，是一个函数对象，它将函数作为参数传递的方式来使用。</p><h2 id="struct仿函数"><a href="#struct仿函数" class="headerlink" title="struct仿函数"></a>struct仿函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+<span class="number">3</span>*y&#125;</span><br><span class="line">&#125;myobj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">myobj</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在struct中进行了()重载。<br>优点：</p><ol><li>仿函数比函数指针的执行速度快，函数指针时通过地址调用，而仿函数是对运算符operator进行自定义来提高调用的效率。</li><li>仿函数比一般函数灵活，可以同时拥有两个不同的状态实体，一般函数不具备此种功能。</li><li>仿函数可以作为模板参数使用，因为每个仿函数都拥有自己的类型。</li></ol><p>缺点：</p><ol><li>需要单独实现一个类。</li><li>定义形式比较复杂。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针，踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C++ QT中的 Widget::Widget(QWidget *parent) :QWidget(parent)</title>
      <link href="/QTwidget/"/>
      <url>/QTwidget/</url>
      
        <content type="html"><![CDATA[<p>如何理解下面段代码?</p><pre><code>Widget::Widget(QWidget *parent) :    QWidget(parent)&#123;&#125;</code></pre><p>在讲解原因之前，先请大家看下面的一个例子:</p><pre><code>#include &lt;iostream&gt;using namespace std;class Base&#123;public:    Base() :m_num(0)&#123;        cout &lt;&lt; &quot;this is Base()&quot; &lt;&lt; endl;    &#125;    Base(int val):m_num(val)&#123;        cout &lt;&lt; &quot;this is Base(int val)&quot; &lt;&lt; endl;    &#125;private:    int m_num;&#125;;</code></pre><p> 上方代码定义了一个基类Base，并且有两个构造函数，一个是默认构造函数，一个是有一个整型参数的构造函数。</p><pre><code>class BaseChild: public Base&#123;public:    BaseChild()&#123;        cout &lt;&lt; &quot;this is BaseChild()&quot; &lt;&lt; endl;    &#125;    BaseChild(int val): Base(val)&#123;        cout &lt;&lt; &quot;this is BaseChild(val)&quot; &lt;&lt; endl;    &#125;private:    int m_num;&#125;;</code></pre><p>上方代码定义了一个BaseChild类，并继承Base类，同样的，它也定义了两个构造函数，一个默认，一个有整型参数。</p><pre><code>int main(int argc, char *argv[])&#123;    BaseChild child1;    BaseChild child2(5);    return 0;&#125;</code></pre><p>main函数实例化了两个子类实例，child1，child2。child1调用默认构造函数。child2调用有整型参数的构造函数。<br>现在，我们运行程序，会有如下打印：<br><img src="/img/1.png" alt=""><br>看到了吗，我们发现：<br> ·创建child1时，是先调用了Base的默认构造函数，再调用自己的默认构造函数<br> ·创建child2时，是先调用了Base(int)这个构造函数，再调用自己的整型参数构造函数。</p><p>所以我们回头看BaseChild的构造函数:</p><pre><code>BaseChild(int val): Base(val)&#123;        cout &lt;&lt; &quot;this is BaseChild(val)&quot; &lt;&lt; endl;    &#125;</code></pre><p>细心的同学，可能早就发现了，初始化列表中的Base(val)正是调用了我们Base基类的有参构造函数，而这样的写法就刚好是我们开头代码中的那段:<br>Widget::Widget(QWidget <em>parent) :QWidget(parent)<br>所以Widget是调用了QWidget下面的构造函数:<br>QWidget(QWidget</em> parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags());<br>所以得出如下总结：<br>总结：<br>· 如果不指定构造函数，则派生类会调用基类的默认构造函数<br>· 派生类构造函数的初始化列表只能初始化派生类成员，不能直接初始化继承成员，如果想 要调用基类的有参构造函数，则可以在派生类的初始化列表中显示指定</p><p>以上总结，也告诉我们，当定义一个类时，最好为该类定义默认构造函数。<br>好的，那么我们又提出一个问题，“调用QWidget(parent)这个构造函数，QWidget父类都做了哪些动作呢？”<br>下面是QWidget源码中的一部分节选：</p><pre><code>QWidget::QWidget( QWidget *parent, const char *name, WFlags f )    : QObject( parent, name ), QPaintDevice( PDT_WIDGET ),    pal( parent ? parent-&gt;palette()        // use parent&#39;s palette        : *qApp-&gt;palette() )            // use application palette&#123;    if ( parent ) &#123;    QChildEvent *e = new QChildEvent( Event_ChildInserted, this );    QApplication::postEvent( parent, e );    &#125;&#125;</code></pre><p>大家从上面可以看出，如果parent参数非空的话，那么该构造函数使用了其父窗口的调色板，并且发送了QChildEvent事件，这会让新的窗口成为parent所指窗口的子窗口，那么当父窗口被删除时，子窗口也会自动的被删除。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++笔记-2</title>
      <link href="/C-%E8%B8%A9%E5%9D%912/"/>
      <url>/C-%E8%B8%A9%E5%9D%912/</url>
      
        <content type="html"><![CDATA[<style>#web_bg{  background: url(/img/19.png)!important;  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/  background-position: center !important;  background-size: cover !important;  background-repeat: no-repeat !important;}</style><h1 id="关于extern的用法："><a href="#关于extern的用法：" class="headerlink" title="关于extern的用法："></a><font color=red size=5 face="黑体">关于extern的用法：</font></h1><p>&emsp;&emsp;利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数，下面就结合具体的实例，分类说明一下。  </p><font color=LightSeaGreen>一、引用同一个文件中的变量</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">func(); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果按照这个顺序，变量 num在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用num这个变量的，因为当编译器编译到这一句话的时候，找不到num这个变量的声明，但是在func函数中是可以正常使用，因为func对num的调用是发生在num的声明和初始化之后。<br>&emsp;&emsp;如果我不想改变num的声明的位置，但是想在main函数中直接使用num这个变量，怎么办呢？可以使用extern这个关键字。像下面这一段代码，利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。但是你要是想欺骗编译器也是不行的，比如你声明了extern int num；但是在后面却没有真正的给出num变量的声明，那么编译器去别的地方找了，但是没找到还是不行的。<br>&emsp;&emsp;下面的程序就是利用extern关键字，使用在后边定义的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">func(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color=LightSeaGreen>二、引用另一个文件中的变量</font>   <p>&emsp;&emsp;如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。<br>&emsp;&emsp;extern这个关键字的真正的作用是引用不在同一个文件中的全局变量或者全局函数。如果将全局变量定义在b.c中，当其他的.cpp文件想要使用该全局变量，#include “包含全局变量的源文件对应的头文件”是无法将其调用过来的。而如果定义在b.h中，则其他源文件#include “b.h”就可以使用全局变量了，但你会说那我把全局变量都定义在.h文件中，其他源文件用的时候#include一下就可以了，根本不需要extern了，extern就没有用了啊！</p><ol><li>这将导致每个包含该头文件的源文件都会生成一个独立的全局变量 num 的副本。这可能会在链接时引发多个重复定义错误。</li><li>一个project会有很多全局变量，这些全局变量的定义一般都放在一个.h文件中，如果你只想使用num这个全局变量,那么每一个使用num的.cpp文件都需要#include “全局变量头文件”，编译器在编译时会给其他全局变量在全局区创造副本，但你并没有使用它们，这样极其耗费资源。<br>&emsp;&emsp;以下面的例子来说，想要调用b.c文件中的全局变量num，出现了以下两种方法：</li><li>在main.cpp中不#include “b.h”,而是加入一行代码 extern int num;可以把这行代码放在main函数中，也可以放在全局区中，也可以放在main.h中。编译器看到extern关键字就会在整个project目录下搜索。见例子一   </li><li>在b.h中加入extern int num,再在main.c中 #include “b.h”。见例子二<br>&emsp;&emsp;例子一：</li></ol><font color=YellowGreen>main.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern int num;下面不加加在这里也可以</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color=YellowGreen>b.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">voidfunc()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fun in a.c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例子二：</p><font color=YellowGreen>b.h</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font color=YellowGreen>b.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font color=YellowGreen>main.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，这里b.c中定义了一个变量num，如果main.c中想要引用这个变量，那么可以使用extern这个关键字，注意这里能成功引用的原因是，num这个关键字在b.c中是一个全局变量，也就是说只有当一个变量是一个全局变量时，extern变量才会起作用，像下面这样num是另一个源文件的局部变量是不行的。   </p><font color=YellowGreen>mian.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">```       </span><br><span class="line"></span><br><span class="line">&lt;font color=YellowGreen&gt;b.c&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">void</span> func()</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun in a.c&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;另外，extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0。像这种写法是不行的。</p><pre><code>extern int num=4;</code></pre><p>&emsp;&emsp;但是在声明之后就可以使用变量名进行修改了，像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line">    num=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;如果不想这个变量被修改可以使用const关键字进行修饰，写法如下：</p><font color=YellowGreen>mian.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color=YellowGreen>b.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num=<span class="number">5</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fun in a.c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好。  </p><font color=LightSeaGreen>三、引用另一文件中的函数</font>   <p>&emsp;&emsp;extern除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似。    </p><font color=YellowGreen>mian.c</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">```     </span><br><span class="line">&lt;font color=YellowGreen&gt;b.c&lt;/font&gt;    </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num=<span class="number">5</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun in a.c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">&amp;emsp;&amp;emsp;这里main函数中引用了b.c中的函数func。因为所有的函数都是全局的，所以对函数的<span class="keyword">extern</span>用法和对全局变量的修饰基本相同，需要注意的就是，需要指明返回值的类型和参数。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="meta"># vector迭代器的坑</span></span><br><span class="line">&amp;emsp;&amp;emsp;在<span class="built_in">vector</span>数组中我们删除数组经常用的就是erase方法，但是earse的用法一不注意就会出错，今天我就遇到了，所以在这里总结一下，避免大家用错。</span><br><span class="line">```c</span><br><span class="line">    <span class="title function_">for</span><span class="params">(<span class="keyword">auto</span> iter=vec.begin();iter!=vec.end(); iter++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter == <span class="number">3</span>)</span><br><span class="line">                veci.erase(iter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里面隐藏着一个很严重的错误：当veci.erase(iter)之后，iter就变成了一个野指针，对一个野指针进行 iter++ 是肯定会出错的。<br>&emsp;&emsp;我们通过查阅文档可以看到erase函数的返回值是这么介绍的：一个迭代器，指定在任何删除的元素之后剩余的第一个元素，如果不存在这样的元素，则指定指向向量结尾的指针。并且比如vector里有4个int型，内存从xxxxx10到xxxxx20,4*4字节=16，这是vector容器的大小。eraser()删除了一个元素，后面的元素补上来，iter指向的内存被释放掉，iter变为野指针，对野指针做任何操作都会报错，因此要重新赋值。这里需要注意，系统给vector初始化的空间是不会变的，删完数据后vector.end()指向的不是初始化的结尾，是实际存储变量的下一个字节。<br>&emsp;&emsp;按如下修改：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=vec.begin();iter!=vec.end(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*iter == <span class="number">3</span>)</span><br><span class="line">            iter = veci.erase(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;但是这种代码也是存在缺陷的，首先是我们无法连续删除数字3，其次是迭代器在指向vec.end()的时候，还会进行一次++，这就发生了数组越界，所以我们一概这样修改：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=vec.begin();iter!=vec.end(); )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( *iter == <span class="number">3</span>)</span><br><span class="line">        iter = veci.erase(iter);<span class="comment">//当删除时erase函数自动指向下一个位置，就不需要进行++</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter ++ ;    <span class="comment">//当没有进行删除的时候，迭代器++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时vec.end()指向的内存是删完后的int型的下一个字节。因此这时cout&lt;&lt;*vec.end();会报错</span></span><br></pre></td></tr></table></figure></p><p>图文讲解：<br>文<br><a href="https://blog.csdn.net/Vcrossover/article/details/106243627">https://blog.csdn.net/Vcrossover/article/details/106243627</a><br>图<br><a href="https://www.cnblogs.com/chaohacker/p/13024357.html">https://www.cnblogs.com/chaohacker/p/13024357.html</a></p><hr><h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><p>&emsp;&emsp;C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。<br>&emsp;&emsp;起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是 stu，要想定义一个结构体变量就得这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;struct 看起来就是多余的，但不写又会报错。如果为 struct stu 起了一个别名 STU，书写起来就简单了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STU stu1;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;使用关键字 typedef 可以为类型起一个新的别名。typedef 的用法一般为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;oldName 是类型原来的名字，newName 是类型新的名字。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;INTEGER a, b;等效于int a, b;。</p><h2 id="数组字符串"><a href="#数组字符串" class="headerlink" title="数组字符串"></a>数组字符串</h2><p>&emsp;&emsp;typedef 还可以给数组、指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ARRAY20[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;表示 ARRAY20 是类型char [20]的别名。它是一个长度为 20 的数组类型。接着可以用 ARRAY20 定义数组：<br>&emsp;&emsp;ARRAY20 a1, a2, s1, s2;<br>它等价于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>];</span><br></pre></td></tr></table></figure></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>&emsp;&emsp;又如，为结构体类型定义别名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">char</span> sex;</span><br><span class="line">&#125; STU;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;STU 是 struct stu 的别名，可以用 STU 定义结构体变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STU body1,body2;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;它等价于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">body1</span>, <span class="title">body2</span>;</span></span><br></pre></td></tr></table></figure></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>&emsp;&emsp;再如，为指针类型定义别名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_ARR)</span>[4];</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;表示 PTR_TO_ARR 是类型int * [4]的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p1, p2;</span><br></pre></td></tr></table></figure></p><h1 id="关于宏定义"><a href="#关于宏定义" class="headerlink" title="关于宏定义"></a>关于宏定义</h1><p>宏定义在预编译阶段就会被替换掉。当编译器不知道宏表示的内容时默认为0。</p><h2 id="typedef-和-宏定义define-的区别"><a href="#typedef-和-宏定义define-的区别" class="headerlink" title="typedef 和 宏定义define 的区别"></a>typedef 和 宏定义define 的区别</h2><p>&emsp;&emsp;typedef 在表现上有时候类似于 #define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把 typedef 看成一种彻底的类型，可以把int<em>这种不属于类型的（int，double是类型）定义为类型。<br>&emsp;&emsp;define是类似于“文本替换”的意思,把···替换成···，#define 定义一个标识符来表示一个常量，其定义的常量值没有类型限定，也不做类型检查（下面由于int</em>本来就不是一个类型，所以出现问题），在出现宏名称的地方直接展开。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。即其在预编译过程中就已经被全部替换掉了，而不需要将其加入到符号表中占用内存。<br>&emsp;&emsp;例如可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERGE int</span></span><br><span class="line"><span class="type">unsigned</span> INTERGE n;  <span class="comment">//没问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTERGE;</span><br><span class="line"><span class="type">unsigned</span> INTERGE n;  <span class="comment">//错误，不能在 INTERGE 前面添加 unsigned</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到变量b的类型是int，其他三个是int<em> 类型。这是因为#define是查找替换，所以替换过后的语句是“int</em>a, b;”，在C语言中，指针并不是一个type（类型）,只有type才能连续定义（比如int c,d）。而typedef是类型转换。这就不难看出b为什么是一个int类型变量，如果要让b也是指针，必须写成“int <em>a, </em>b;”。而我们使用typedef时不会出现这个问题，可以看到c、d都是整型指针。</p><h2 id="关于enum和-define-effective-C-P15"><a href="#关于enum和-define-effective-C-P15" class="headerlink" title="关于enum和#define(effective C++ P15)"></a>关于enum和#define(effective C++ P15)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_PTR int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* int_ptr;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    INT_PTR a, b;<span class="comment">//宏替换后为int* a, b;由于int*不是类型，所以b会被解释为int</span></span><br><span class="line">    int_ptr c, d;<span class="comment">//typedef把int*转换成了类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">t</span></span><br><span class="line">&#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (b==0)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=0\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> (b==1)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=1\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>猜，答案会是多少呢？  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">Process returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.034</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在预编译阶段，编译器会发现 #if (b==0),此时由于这行代码是宏定义，不知道表达式中的b是多少，编译器直接会用0替代（预编译过程中仅仅做的是展开#define，#include,处理条件编译#if,#else，删除注释，添加行号和文件标识符等，并不会执行#if条件下的代码）。因此会如此输出。此外enum中如果没有赋值，会把第一个元素默认为0,往后逐渐加一。</p><hr><h1 id="Union-联合"><a href="#Union-联合" class="headerlink" title="Union(联合)"></a>Union(联合)</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">&#125; data;     </span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为data的union变量。它有什么属性呢？</p><ol><li>这个变量在内存中占用4个字节的空间而不是8个；</li><li>有两个数据成员：int类型变量的i和char类型的数组str；</li><li>虽然有两个数据成员，但是这两个成员对应的存储空间是同一块内存。也就是说定义了char str[4]，访问 i ,得到的结果就是定义了的char str[4]</li></ol><p>&emsp;&emsp;上面三点是union变量的最基本也是最重要的属性。详细说一下第三点。因为union不论包含多少个多少种数据类型，它实例化为变量后，这个变量的长度是这个union中最长的数据类型的长度。下面的代码定义了一个union变量。它的长度是16个字节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DEMO</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> status;</span><br><span class="line">    <span class="type">int</span> a; </span><br><span class="line">    <span class="type">int</span> serial[<span class="number">4</span>]; </span><br><span class="line">&#125;demo；</span><br></pre></td></tr></table></figure></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&emsp;&emsp;C语言中，union相对于struct使用的次数在大部分项目中都处于明显的劣势，这和union的存储方式的特性有很大的关系。在union中，所有的字段都有相同的偏移量，而且所有的字段都是相互重叠的，union的大小是其中最大字段的大小。那我们就知道，如果所有的字段是相互重叠的，那改变其中任何一个字段的值，其他字段的值都会受到影响，也会发生变化。这就造成union在实际使用中使用的频率不会那么高，甚至会认为可能也没有什么用。如果想要使用的话，那么union中的各个字段的使用必须是互斥的，任意时刻只能使用一个。</p><ol><li>判断大小端，union大显身手<br>&emsp;&emsp;一个整数在大小端机器上面存储的顺序是不一样，而union中的各个字段的偏移地址是相同的，那一个数在在大小端机器中存储到union中，如果将这个数拆分，各个部分也会不同。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bits32;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bytes[<span class="number">4</span>];</span><br><span class="line">&#125; TheValue;</span><br><span class="line">TheValue theValue;</span><br><span class="line"><span class="type">int</span> isLittleEndian = <span class="number">0</span>; </span><br><span class="line">theValue.bytes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">theValue.bytes[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">theValue.bytes[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">theValue.bytes[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">isLittleEndian = (theValue.bits32 == <span class="number">256</span>);</span><br><span class="line">#<span class="number">256</span>小端法<span class="number">16</span>进制：<span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">#<span class="number">256</span>大端法<span class="number">16</span>进制：<span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span></span><br></pre></td></tr></table></figure></li><li>创建别名<br>&emsp;&emsp;因为程序中经常会进行类型的强制转换，如果不小心可能就会出错，那么我们就可以利用union中的字段代表想要得到的类型，尤其是指针类型，尤其是代码整合过程中，如果使用了第三方的库，需要将第三方的库merge到自己的代码中，由于编码习惯，命名规则的不同，还是需要将其他库的一些类型转换为自己习惯的方式或者公司的方式。一般情况我们是能看到库的header file的，结构类型什么的都可以看到。我们会按照库的header file写一份自己的。<br>&emsp;&emsp;例如库中header file有一个struct 名字是ThirdTest<br>&emsp;&emsp;那么我们在header file中创造一个一个对应的struct 名字是OurTestThird<br>&emsp;&emsp;那么就可以弄一个union<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    ThirdTest * thirdTest;</span><br><span class="line">    OurTestThird *ourTestThird;</span><br><span class="line">&#125; TestThird;</span><br></pre></td></tr></table></figure>&emsp;&emsp;那我们使用一下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestThird testThird;</span><br><span class="line">testThird.thirdTest = getCallOneFunction(); <span class="comment">//这个一个库函数，返回的类型是ThirdTest *</span></span><br><span class="line">CallOurSomeOneFunction(testThird. ourTestThird); <span class="comment">//这个是自己的函数，参数类型是OurTestThird *</span></span><br></pre></td></tr></table></figure>&emsp;&emsp;那这个union TestThird就起到了将类型ThirdTest <em>强转为OurTestThird </em>的作用，union起到了一个桥梁的作用和粘合剂的作用，不然就需要一个表将自己的类型和库的类型一一对应起来。<br>&emsp;&emsp;当然这个例子有些牵强，有很多办法将类型对应起来，这里只是针对别名列举一个例子而已。</li><li>将union中较大的对象分解成组成这个对象的各个字节。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">unsiged <span class="type">int</span> u;</span><br><span class="line">unsiged <span class="type">char</span> bytes[<span class="number">4</span>];</span><br><span class="line">&#125; asBytes;</span><br><span class="line">asBytes composite;</span><br><span class="line">composite.u = <span class="number">1234576890</span>;</span><br><span class="line"><span class="built_in">printf</span> (“HO byte of composite.u is %u, LO byte is %u\n”, composite.bytes[<span class="number">3</span>], composite.bytes[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li></ol><h1 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h1><h2 id="关键字enum的定义"><a href="#关键字enum的定义" class="headerlink" title="关键字enum的定义"></a>关键字enum的定义</h2><p>&emsp;&emsp;enum是C语言中的一个关键字，enum叫枚举数据类型，枚举数据类型描述的是一组整型值的集合（这句话其实不太妥当），枚举型是预处理指令#define的替代，枚举和宏其实非常类似，宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值，</p><p>&emsp;&emsp;我们可以将枚举理解为编译阶段的宏，使用格式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">typeName</span> &#123;</span> valueName1, valueName2, valueName3, ...... &#125;;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;typeName是枚举类型的名字，花括号里面的元素（枚举成员）是常量而不是变量，这个一定要搞清楚，因为枚举成员的是常量，所以不能对它们赋值，只能将它们的值赋给其他的变量。<br>&emsp;&emsp;枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。<br>&emsp;&emsp;接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#defineMON <span class="number">1</span></span><br><span class="line">#defineTUE <span class="number">2</span></span><br><span class="line">#defineWED <span class="number">3</span></span><br><span class="line">#defineTHU <span class="number">4</span></span><br><span class="line">#defineFRI <span class="number">5</span></span><br><span class="line">#defineSAT <span class="number">6</span></span><br><span class="line">#defineSUN <span class="number">7</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这个看起来代码量就比较多，接下来我们看看使用枚举的方式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样看起来是不是更简洁了。</p><h3 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h3><ol><li>枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。</li><li>Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。<br>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。</li><li>第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。在当前值没有赋值的情况下，枚举类型的当前值总是前一个值+1.</li><li>枚举的每个常量都是按照整数int类型来存储的。</li></ol><h2 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h2><p>&emsp;&emsp;前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。<br>&emsp;&emsp;我们可以通过以下三种方式来定义枚举变量</p><ol><li>先定义枚举类型，再定义枚举变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure></li><li>定义枚举类型的同时定义枚举变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></li><li>省略枚举名称，直接定义枚举变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>&emsp;&emsp;同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量。<font color=red>错误示例</font>如下所示：  </li><li>存在同名的枚举类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">wednesday,</span><br><span class="line">thursday,</span><br><span class="line">friday</span><br><span class="line">&#125; workday;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">WEEK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">saturday,</span><br><span class="line">sunday = <span class="number">0</span>,</span><br><span class="line">monday,</span><br><span class="line">&#125; workday;</span><br></pre></td></tr></table></figure></li><li>存在同名的枚举成员<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">wednesday,</span><br><span class="line">thursday,</span><br><span class="line">friday</span><br><span class="line">&#125; workday_1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">WEEK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">wednesday,</span><br><span class="line">sunday = <span class="number">0</span>,</span><br><span class="line">monday,</span><br><span class="line">&#125; workday_2;</span><br></pre></td></tr></table></figure><h2 id="使用枚举类型的变量"><a href="#使用枚举类型的变量" class="headerlink" title="使用枚举类型的变量"></a>使用枚举类型的变量</h2><h3 id="对枚举型的变量赋值"><a href="#对枚举型的变量赋值" class="headerlink" title="对枚举型的变量赋值"></a>对枚举型的变量赋值</h3>实例将枚举类型的赋值与基本数据类型的赋值进行了对比：  </li><li>先声明变量，再对变量赋值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="comment">/* 定义枚举类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 使用基本数据类型声明变量，然后对变量赋值 */</span></span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">20</span>;</span><br><span class="line">    z = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用枚举类型声明变量，再对枚举型变量赋值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">yesterday</span>, <span class="title">today</span>, <span class="title">tomorrow</span>;</span></span><br><span class="line"></span><br><span class="line">    yesterday = MON;</span><br><span class="line">    today = TUE;</span><br><span class="line">    tomorrow = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, yesterday, today, tomorrow);</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line"><span class="number">2.</span> 声明变量的同时赋初值  </span><br><span class="line">```c</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="comment">/* 定义枚举类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 使用基本数据类型声明变量同时对变量赋初值 */</span></span><br><span class="line">    <span class="type">int</span> x=<span class="number">10</span>, y=<span class="number">20</span>, z=<span class="number">30</span>;</span><br><span class="line">    <span class="comment">/* 使用枚举类型声明变量同时对枚举型变量赋初值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">yesterday</span> =</span> MON,</span><br><span class="line">    today = TUE,</span><br><span class="line">    tomorrow = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, yesterday, today, tomorrow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>定义类型的同时声明变量，然后对变量赋值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 定义枚举类型，同时声明该类型的三个变量，它们都为全局变量 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN &#125; yesterday, today, tomorrow;</span><br><span class="line"><span class="comment">/* 定义三个具有基本数据类型的变量，它们都为全局变量 */</span></span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 对基本数据类型的变量赋值 */</span></span><br><span class="line">    x = <span class="number">10</span>; y = <span class="number">20</span>; z = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对枚举型的变量赋值 */</span></span><br><span class="line">    yesterday = MON;</span><br><span class="line">    today = TUE;</span><br><span class="line">    tomorrow = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, x, y, z); <span class="comment">//输出：10 20 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, yesterday, today, tomorrow); <span class="comment">//输出：1 2 3</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>类型定义，变量声明，赋初值同时进行。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 定义枚举类型，同时声明该类型的三个变量，并赋初值。它们都为全局变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    MON=<span class="number">1</span>,</span><br><span class="line">    TUE,</span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">    &#125;</span><br><span class="line">    yesterday = MON, today = TUE, tomorrow = WED;</span><br><span class="line">    <span class="comment">/* 定义三个具有基本数据类型的变量，并赋初值。它们都为全局变量 */</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>, z = <span class="number">30</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, x, y, z); <span class="comment">//输出：10 20 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, yesterday, today, tomorrow); <span class="comment">//输出：1 2 3</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>注意：给枚举变量赋予初值后再次赋值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">yesterday</span>, <span class="title">today</span>, <span class="title">tomorrow</span>;</span></span><br><span class="line">yesterday = TUE;</span><br><span class="line">today = (<span class="keyword">enum</span> DAY) (yesterday + <span class="number">1</span>); <span class="comment">//类型转换</span></span><br><span class="line">tomorrow = (<span class="keyword">enum</span> DAY) <span class="number">30</span>; <span class="comment">//类型转换</span></span><br><span class="line"><span class="comment">//tomorrow = 3; //错误</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d \n&quot;</span>, yesterday, today, tomorrow); <span class="comment">//输出：2 3 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举与-define-宏的区别"><a href="#枚举与-define-宏的区别" class="headerlink" title="枚举与#define 宏的区别"></a>枚举与#define 宏的区别</h2>下面再看看枚举与#define 宏的区别：</li><li>define 宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值（在预编译阶段使用enum值会出错，因为在编译阶段才确定其值）。</li><li>一般在编译器里，可以调试枚举常量，但是不能调试宏常量。</li><li>枚举可以一次定义大量相关的常量，而#define 宏一次只能定义一个。</li></ol><h1 id="malloc函数与calloc函数"><a href="#malloc函数与calloc函数" class="headerlink" title="malloc函数与calloc函数"></a>malloc函数与calloc函数</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="malloc函数原型"><a href="#malloc函数原型" class="headerlink" title="malloc函数原型"></a>malloc函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_bytes)</span>;</span><br></pre></td></tr></table></figure><p>意为分配长度为num_bytes字节的内存块  </p><h3 id="malloc函数头文件"><a href="#malloc函数头文件" class="headerlink" title="malloc函数头文件"></a>malloc函数头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="malloc函数返回值"><a href="#malloc函数返回值" class="headerlink" title="malloc函数返回值"></a>malloc函数返回值</h3><p>如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。</p><h3 id="malloc函数使用注意事项"><a href="#malloc函数使用注意事项" class="headerlink" title="malloc函数使用注意事项"></a>malloc函数使用注意事项</h3><ol><li>malloc函数的返回的是无类型指针，在使用时一定要强制转换为所需要的类型。</li><li>重点：在使用malloc开辟空间时，使用完成一定要释放空间，如果不释放会造内存泄漏。</li><li>在使用malloc函数开辟的空间中，不要进行指针的移动，因为一旦移动之后可能出现申请的空间和释放空间大小的不匹配<h3 id="malloc使用"><a href="#malloc使用" class="headerlink" title="malloc使用"></a>malloc使用</h3>&emsp;&emsp;关于malloc所开辟空间类型：malloc只开辟空间，不进行类型检查，只是在使用的时候进行类型的强转。举个例子：‘我’开辟你所需要大小的字节大小空间，至于怎么使用是你的事<br>&emsp;&emsp;mallo函数返回的实际是一个无类型指针，必须在其前面加上指针类型强制转换才可以使用<br>&emsp;&emsp;指针自身 = (指针类型 <em>）malloc（sizeof（指针类型）</em>数据数量）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);</span><br></pre></td></tr></table></figure>&emsp;&emsp;在使用malloc函数之前我们一定要计算字节数，malloc开辟的是用户所需求的字节数大小的空间。<br>如果多次申请空间那么系统是如何做到空间的不重复使用呢？<br>&emsp;&emsp;在使用malloc开辟一段空间之后，系统会在这段空间之前做一个标记（0或1），当malloc函数开辟空间如果遇到标记为0就在此开辟，如果为1说明此空间正在被使用。<h3 id="释放函数free"><a href="#释放函数free" class="headerlink" title="释放函数free()"></a>释放函数free()</h3>作用：释放malloc(或calloc、realloc)函数给指针变量分配的内存空间。<br>注意：使用后该指针变量一定要重新指向NULL，防止悬空指针（失效指针）出现，有效规避错误操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *p = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>free函数在释放空间之后，把内存前的标志变为0，且为了防止数据泄露，它会把所释放的空间用cd进行填充。</li></ol><hr><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>&emsp;&emsp;calloc函数，其原型void <em>calloc(size_t n, size_t size)；<br>&emsp;&emsp;其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int </em>p = (int *)calloc(20, sizeof(int)）,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;</p><h2 id="calloc与malloc区别"><a href="#calloc与malloc区别" class="headerlink" title="calloc与malloc区别"></a>calloc与malloc区别</h2><ol><li>函数malloc不能初始化所分配的内存空间,而函数calloc能.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题.</li><li>函数calloc() 会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零.</li></ol><p>&emsp;&emsp;疑问：既然calloc不需要计算空间并且可以直接初始化内存避免错误，那为什么不直接使用calloc函数，那要malloc要什么用呢？<br>&emsp;&emsp;实际上，任何事物都有两面性，有好的一面，必然存在不好的地方。这就是效率。calloc函数由于给每一个空间都要初始化值，那必然效率较malloc要低，并且现实世界，很多情况的空间申请是不需要初始值的，这也就是为什么许多初学者更多的接触malloc函数的原因。</p><hr><h1 id="如何初始化链表"><a href="#如何初始化链表" class="headerlink" title="如何初始化链表"></a>如何初始化链表</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span><span class="comment">//指针域，指向下一个结点 </span></span><br><span class="line">&#125;link;<span class="comment">//typedef把link另作为struct Node变量类型的名字 </span></span><br><span class="line"></span><br><span class="line">link *<span class="title function_">initLink</span><span class="params">()</span>&#123;</span><br><span class="line">link *head=<span class="literal">NULL</span>;<span class="comment">//创建一个头结点 </span></span><br><span class="line">head=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//动态内存分配 </span></span><br><span class="line">link *temp=head;<span class="comment">//创建一个临时指针，并且指向头结点 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp-&gt;data); <span class="comment">//从键盘输入头结点的值 </span></span><br><span class="line"><span class="keyword">while</span>(temp-&gt;data!=<span class="number">0</span>)&#123; <span class="comment">//只要不输入0就会一直创建新的结点 </span></span><br><span class="line">link *a=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">temp-&gt;next=a;</span><br><span class="line">temp=a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next=<span class="literal">NULL</span>; </span><br><span class="line">temp=head;<span class="comment">//输入0后，temp指针就会指回头结点 </span></span><br><span class="line"><span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;<span class="comment">//打印 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">link *p=initLink();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附leetcode第二题：两数加和"><a href="#附leetcode第二题：两数加和" class="headerlink" title="附leetcode第二题：两数加和"></a>附leetcode第二题：两数加和</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> &#123;</span><br><span class="line">        ListNode* result = new ListNode(<span class="number">0</span>);<span class="comment">//这里如果定义ListNode* result = nullptr，那么之后result-&gt;next会报错，因为根本没定义</span></span><br><span class="line">        ListNode*head = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><hr><h1 id="哈希表unordered-map、unordered-set"><a href="#哈希表unordered-map、unordered-set" class="headerlink" title="哈希表unordered_map、unordered_set"></a>哈希表unordered_map、unordered_set</h1><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><font color=YellowGreen>定义</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::unordered_map，将字符串键映射到整数值</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    hashMap[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    hashMap[<span class="string">&quot;banana&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">    hashMap[<span class="string">&quot;cherry&quot;</span>] = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并访问值</span></span><br><span class="line">    <span class="keyword">if</span> (hashMap.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>) != hashMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for &#x27;banana&#x27;: &quot;</span> &lt;&lt; hashMap[<span class="string">&quot;banana&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    hashMap.<span class="built_in">erase</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历无序映射</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : hashMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="type">int</span>&gt; hashMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;cherry&quot;</span>, <span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = hashMap.find(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != hashMap.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value for &#x27;banana&#x27;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&#x27;banana&#x27; not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><font color=YellowGreen>定义</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::unordered_set</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; hashSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到哈希集合</span></span><br><span class="line">    hashSet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    hashSet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashSet.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查元素是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (hashSet.<span class="built_in">find</span>(<span class="number">10</span>) != hashSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;10 exists in the hashSet.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    hashSet.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : hashSet) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元素查找与删除"><a href="#元素查找与删除" class="headerlink" title="元素查找与删除"></a>元素查找与删除</h3><p>&emsp;&emsp;在C++的 std::unordered_set 中，元素是无序存储的，并且没有类似于数组索引的概念来直接访问元素。你不能通过 hashSet[ 0 ]、hashSet[ 1 ] 这样的方式来访问元素，因为哈希集合的元素是通过其值进行唯一标识的，而不是通过索引。</p><p>&emsp;&emsp;在你的代码中，添加元素的顺序不会影响元素的存储和访问顺序。所以，无法根据索引来直接访问哈希集合中的元素。你只能使用 find 函数来检查元素是否存在，或者使用范围循环来遍历哈希集合中的元素，如我之前给出的示例代码所示。<br>&emsp;&emsp;std::unordered_set 中的 find 函数会返回一个迭代器，指向要查找的元素。如果元素不存在，它会返回迭代器等于 hashSet.end()。  </p><font color=YellowGreen>元素查找</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; hashSet = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = hashSet.find(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != hashSet.end()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Element not found.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><font color=YellowGreen>元素删除</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; hashSet = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空哈希集合</span></span><br><span class="line">    hashSet.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在哈希集合为空</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of hashSet after clearing: &quot;</span> &lt;&lt; hashSet.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="如何在C-程序中定义计时器？"><a href="#如何在C-程序中定义计时器？" class="headerlink" title="如何在C++程序中定义计时器？"></a>如何在C++程序中定义计时器？</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> time_Start = <span class="built_in">clock</span>();<span class="comment">//读当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里放执行的语句</span></span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="built_in">clock</span>()-time_Start&lt;&lt;endl;<span class="comment">//再次获取当前时间并减掉上次读的时间。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="C-中函数的栈帧？"><a href="#C-中函数的栈帧？" class="headerlink" title="C++中函数的栈帧？"></a>C++中函数的栈帧？</h1><p><a href="https://zhuanlan.zhihu.com/p/665191596">https://zhuanlan.zhihu.com/p/665191596</a></p><hr><h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><h2 id="浅拷贝例子"><a href="#浅拷贝例子" class="headerlink" title="浅拷贝例子"></a>浅拷贝例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShallowCopyExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShallowCopyExample</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ShallowCopyExample</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ShallowCopyExample <span class="title">original</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    ShallowCopyExample shallow_copy = original; <span class="comment">// 浅拷贝</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original data: &quot;</span> &lt;&lt; original.data &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shallow copy data: &quot;</span> &lt;&lt; shallow_copy.data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    original.data[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After modifying original:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original data: &quot;</span> &lt;&lt; original.data &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shallow copy data: &quot;</span> &lt;&lt; shallow_copy.data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面例子中，由于data是个指针，浅拷贝只会把指针本身粘贴过去，因此当改变Original中的内容时，shallow_copy也会被拷贝过去。</p><h2 id="深拷贝的特点："><a href="#深拷贝的特点：" class="headerlink" title="深拷贝的特点："></a>深拷贝的特点：</h2><ol><li>深拷贝是指在复制一个对象时，会复制该对象本身以及该对象所包含的所有数据，包括对象内部的所有数据成员，以及嵌套对象的数据。</li><li>深拷贝创建了一个完全独立于原始对象的新对象，它们不共享内部数据。</li><li>深拷贝通常涉及递归遍历对象的所有嵌套部分，确保每个部分都被复制，以便在新对象中保留相同的值。</li></ol><h2 id="浅拷贝的特点："><a href="#浅拷贝的特点：" class="headerlink" title="浅拷贝的特点："></a>浅拷贝的特点：</h2><ol><li>浅拷贝是指在复制一个对象时，只复制对象本身，而不复制对象内部的数据。</li><li>浅拷贝创建了一个新对象，该对象与原始对象共享内部数据，这意味着它们指向相同的数据成员或嵌套对象。</li><li>浅拷贝通常只涉及复制对象的成员指针或引用，而不复制指针或引用指向的实际数据。</li></ol><hr><h1 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h1><h2 id="typename作用"><a href="#typename作用" class="headerlink" title="typename作用"></a>typename作用</h2><p>&emsp;&emsp;typename关键字用于引入一个模板参数，这个关键字用于指出模板声明（或定义）中的非独立名称（dependent names）是类型名，而非变量名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何理解代码typedef-typename-std-vector-size-type-size-type"><a href="#如何理解代码typedef-typename-std-vector-size-type-size-type" class="headerlink" title="如何理解代码typedef typename std::vector::size_type size_type;"></a>如何理解代码typedef typename std::vector<T>::size_type size_type;</h2><p>&emsp;&emsp;typename 在这里的意思表明 T 是一个类型。如果没有它的话，在某些情况下会出现模棱两可的情况，比如下面这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T::iterator * iter;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;作者想定义一个指针iter，它指向的类型是包含在类作用域T中的iterator。可能存在这样一个包含iterator类型的结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContainsAType</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iterator</span> &#123; <span class="comment">/*...*/</span> &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么 foo&lt; ContainsAType&gt;()&gt;; 这样用的是时候确实可以知道 iter是一个ContainsAType::iterator类型的指针。但是T::iterator实际上可以是以下三种中的任何一种类型：</p><ol><li>静态数据成员</li><li>静态成员函数</li><li>嵌套类型</li></ol><p>所以如果是下面这样的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContainsAnotherType</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> iterator;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那T::iterator <em> iter;被编译器实例化为ContainsAnotherType::iterator </em> iter;，变成了一个静态数据成员乘以 iter ，这样编译器会找不到另一个变量iter的定义 。所以为了避免这样的歧义，我们加上 typename，表示T::iterator一定要是个类型才行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::iterator * iter;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>&emsp;&emsp;我们回到一开始的例子，对于 vector::size_type，我们可以知道：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;vector::size_type是vector的嵌套类型定义，其实际等价于size_t类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么这个例子的真实目的是，typedef创建了存在类型的别名，而typename告诉编译器std::vector<T>::size_type是一个类型而不是一个成员。</p><hr><h1 id="类中的拷贝构造函数"><a href="#类中的拷贝构造函数" class="headerlink" title="类中的拷贝构造函数"></a>类中的拷贝构造函数</h1><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><a href="https://blog.csdn.net/qq_43519886/article/details/105170209">https://blog.csdn.net/qq_43519886/article/details/105170209</a></p><hr><h1 id="const-cast、static-cast、dynamic-cast、reinterpret-cast"><a href="#const-cast、static-cast、dynamic-cast、reinterpret-cast" class="headerlink" title="const_cast、static_cast、dynamic_cast、reinterpret_cast"></a>const_cast、static_cast、dynamic_cast、reinterpret_cast</h1><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ol><li>const_cast只针对指针、引用，当然，this指针也是其中之一。</li><li>const_cast的大部分使用主要是将常量指针转换为常指针。常量指针指向的空间的内容不允许被修改，但是使用const_cast进行强制转换就可以修改。</li><li>const_cast只能调节类型限定符，不能修改基本类型。在普通指针演示中给出示例。</li><li>const_cast作用了之后还是const。</li></ol><p>(1)普通指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//int* d = p;//错误原因：const int*类型不能赋值或者初始化int*类型的实体</span></span><br><span class="line">*<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p) = <span class="number">50</span>;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//50，原来的常量被改变了</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* d = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);</span><br><span class="line">*d = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char* dd = const_cast&lt;char*&gt;(p)//错误原因：const_cast只能调节类型限定符，不能更改基础类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>（2）引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="comment">//b = 20;//错误原因：常量引用，不允许修改值;但是a是可以更改的，a=20是正确的</span></span><br><span class="line"><span class="comment">//int&amp; c = b;//错误，和常量指针不允许给普通指针赋值或者初始化一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; c = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(b);</span><br><span class="line">c = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(b) = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3)this指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span><span class="type">const</span><span class="comment">//此时this指针相当于const Test* const this</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//this-&gt;val1 = 10;//错误</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;Test*&gt;(<span class="keyword">this</span>)-&gt;val1 = <span class="number">10</span>;<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> val1;</span><br><span class="line"><span class="type">int</span> val2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ol><li>static_cast的使用基本等价于隐式转换的一种类型转化运算符，可使用于需要明确隐式转换的地方。就相当于把隐式转换给明确写了出来而已。</li><li>什么叫低风险的转化，一般只要编译器能自己进行隐式转换的都是低风险转换，一般平等转换和提升转换都是低风险的转换。</li></ol><ul><li>整形和浮点型</li><li>字符与整形</li><li>转换运算符</li><li>空指针转换为任何目标类型的指针</li></ul><ol><li>不可以用于风险较高的转换</li></ol><ul><li>不同类型的指针之间互相转换</li><li>非指针类型和指针类型之间的相互转换</li><li>不同类型的引用之间的转换</li></ul><ol><li>关于继承关系的指针/引用转换：因为static_cast的转换时粗暴的，它仅根据类型转换语句中提供的信息（尖括号中的类型）来进行转换，这种转换方式对于上行转换，由于子类总是包含父类的所有数据成员和函数成员，因此从子类转换到父类的指针对象可以没有任何顾虑的访问其（指父类）的成员。而对于下行转换为什么不安全，是因为static_cast只是在编译时进行类型坚持，没有运行时的类型检查，具体原理在dynamic_cast中说明。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>() &#123;&#125;</span><br><span class="line">~<span class="built_in">Son</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> c_a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i_a = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> f_a = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> d_a = <span class="number">1.111111</span>;</span><br><span class="line"><span class="type">void</span>* v_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* i_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">char</span>* c_ptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面部分没有报错，可以运行，但是平时不允许这样写，除非自己很明确自己在干什么</span></span><br><span class="line"><span class="comment">//从高字节数到低字节数的转换平常肯定是不允许这样用的，因为将一个多字节的内容转换到少字节，非常容易丢失数据</span></span><br><span class="line"><span class="type">char</span> c_sc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i_a);</span><br><span class="line">c_sc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(f_a);</span><br><span class="line">c_sc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(d_a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于下面的转换不允许，因为两个不同的指针类型之间不允许相互转换</span></span><br><span class="line"><span class="comment">//int* i_scptr = static_cast&lt;int*&gt;(c_ptr);//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的指针类型转换允许</span></span><br><span class="line"><span class="type">int</span>* i_scptr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(v_ptr);</span><br><span class="line"><span class="type">void</span>* v_scptr = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(i_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的可取，只不过有时候精度可能会降低而已，比如float转换为int，被视为低风险</span></span><br><span class="line"><span class="type">float</span> f_sc = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i_a);</span><br><span class="line"><span class="type">int</span> i_sc = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c_a);</span><br><span class="line">cout &lt;&lt; i_sc &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类指针和派生类指针的指向问题</span></span><br><span class="line">Base* bptr1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">Son* sptr1 = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">Base* bptr;</span><br><span class="line">Son* sptr;</span><br><span class="line">bptr = <span class="keyword">new</span> <span class="built_in">Son</span>();    <span class="comment">//语句1   正确，基类指针指向派生类实体,派生类指针转化为基类</span></span><br><span class="line"><span class="comment">//sptr = new Base();//语句2   错误，派生类指针指向父类，即基类指针转化为派生类指针不对</span></span><br><span class="line">bptr = <span class="built_in">static_cast</span>&lt;Base*&gt;(sptr1);<span class="comment">//等同于语句1，正确</span></span><br><span class="line">sptr = <span class="built_in">static_cast</span>&lt;Son*&gt;(bptr1); <span class="comment">//等同于语句2，但是不安全，平时使用也不会使派生类指针指向基类,会出现访问越界，有时候会崩溃，有时候我们却没办法发现</span></span><br><span class="line"><span class="comment">//对于派生类指针指向基类（基类指针转化为派生类），会用另一个强制转换dynamic_cast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ol><li>dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</li><li>当一个类中拥有至少一个虚函数的时候，编译器会为该类构建出一个虚函数表（virtual method table），虚函数表记录了虚函数的地址。如果该类派生了其他子类，且子类定义并实现了基类的虚函数，那么虚函数表会将该函数指向新的地址。虚表是C++多态实现的一个重要手段，也是dynamic_cast操作符转换能够进行的前提条件。当类没有虚函数表的时候（也即一个虚函数都没有定义）,dynamic_cast无法使用RTTI，不能通过编译（个人猜想…有待验证）。当然，虚函数表的建立对效率是有一定影响的，构建虚函数表、由表查询函数 都需要时间和空间上的消耗。所以，除了必须声明virtual（对于一个多态基类而言），不要轻易使用virtual函数。对于虚函数的进一步了解，可以查看《Effective C++》  </li></ol><ul><li>如果一条dynamic_cast语句的转换目标是指针类型并且失败了，那么返回类型是一个空指针，结果是所需类型的空指针。</li><li>如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。<br>非必要不使用dynamic_cast，因为有额外的开销。</li></ul><ol><li>常用的转换方式<br>派生类指针或引用指向基类指针（上行转换）（因为都是安全的，所以可以使用dynamic_cast,但是更推荐用static_cast，dynamic_cast过于消耗资源）<br>基类指针或引用指向派生类指针（下行转换）（必须使用dynamic_cast,static_cast不会进行安全检查）  </li></ol><p>&emsp;&emsp;dynamic_cast只有当父类指针或引用真正指向子类对象时才能成功转换。说到下行转换，有一点需要了解的是在C++中，一般是可以用父类指针指向一个子类对象，如parent<em> P1 = new Children(); 但这个指针只能访问父类定义的数据成员和函数，这是C++中的静态联翩，但一般不定义指向父类对象的子类类型指针，如Children</em> P1 = new parent；这种定义方法不符合生活习惯，在程序设计上也很麻烦。这就解释了也说明了，在上行转换中，static_cast和dynamic_cast效果是一样的，而且都比较安全，因为向上转换的对象一般是指向子类对象的子类类型指针,转换成的父对象中的功能是子函数的一个子集，肯定都定义好了；而在下行转换中，想把父对象转化为子对象，由于子对象中功能很多（父对象功能是子对象的子集），转换后的子对象一定是功能缺失的，这时static_cast编译会过，但运行时会报错；而dynamic_cast是运行时类型检查，编译时发现功能不齐就不报错，而是运行时返回一个bad_cast或者空指针，就很灵活。下面通过代码进行说明 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//一定要有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于需要进行向下转换，因此需要定义一个父类类型的指针Base *P，但是由于子类继承与父类，父类指针可以指向父类对象，也可以指向子类对象，这就是重点所在。如果 P指向的确实是子类对象，则dynamic_cast和static_cast都可以转换成功，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Base *P = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived *pd1 = <span class="built_in">static_cast</span>&lt;Derived *&gt;(P);</span><br><span class="line">Derived *pd2 = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(P);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上转换都能成功。但是，如果 P 指向的不是子类对象，而是父类对象，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Base *P = <span class="keyword">new</span> Base;</span><br><span class="line">Derived *pd3 = <span class="built_in">static_cast</span>&lt;Derived *&gt;(P);</span><br><span class="line">Derived *pd4 = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(P);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在以上转换中，static_cast转换在编译时不会报错，也可以返回一个子类对象指针（假想），但是这样是不安全的，在运行时可能会有问题，因为子类中包含父类中没有的数据和函数成员，这里需要理解转换的字面意思，转换是什么？转换就是把对象从一种类型转换到另一种类型，如果这时用 pd3 去访问子类中有但父类中没有的成员，就会出现访问越界的错误，导致程序崩溃。而dynamic_cast由于具有运行时类型检查功能，它能检查P的类型，由于上述转换是不合理的，所以它返回NULL。</p><p>例子2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::f1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base* pbase1 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">Derive* pderive1 = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(pbase1); <span class="comment">//down-cast</span></span><br><span class="line">pderive1-&gt;<span class="built_in">f</span>(); <span class="comment">// Derive::f()</span></span><br><span class="line">pderive1-&gt;<span class="built_in">f2</span>();<span class="comment">//Derive::f1()</span></span><br><span class="line"></span><br><span class="line">Base* pbase2 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">Derive* pderive3 = <span class="built_in">static_cast</span>&lt;Derive*&gt;(pbase2); <span class="comment">//up-cast</span></span><br><span class="line">pderive3-&gt;<span class="built_in">f</span>();<span class="comment">//这里会输出Base::f()！证明没有成功转化</span></span><br><span class="line">pderive3-&gt;<span class="built_in">f2</span>();<span class="comment">//运行时在这报错</span></span><br><span class="line">Derive* pderive2 = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(pbase2); <span class="comment">//up-cast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pderive2) <span class="comment">// NULL</span></span><br><span class="line">&#123;</span><br><span class="line">pderive2-&gt;<span class="built_in">f</span>();</span><br><span class="line">pderive2-&gt;<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//执行了这个</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pbase1;</span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>&emsp;&emsp;这个和C语言的强制转换没什么区别，只不过C++用自己的写法替代了C语言的强制转换而已。   </p><ol><li>不同类型的指针之间的转换</li><li>指针和能容纳指针的整数类型之间的转换（比如将int类型强转成int*类型）</li><li>不同类型的引用之间的转换<br>编译期处理执行的是逐字节复制的操作。<br>&emsp;&emsp;这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int<em> 指针、函数指针或其他类型的指针转换成 string</em> 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针，踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT如何连接mysql</title>
      <link href="/database/"/>
      <url>/database/</url>
      
        <content type="html"><![CDATA[<p>1：下载并安装mysql<br>配置环境变量：在用户与系统中的path路径分别加入mysql bin文件夹的地址，我的如下：<br>D:\mySQL\MySQL Server 8.0\bin<br>这一步是为了打开cmd直接输入： mysql -u root -p就可以登陆操作数据库，不然只能在D:\mySQL\MySQL Server 8.0\bin打开cmd操作数据库。</p><p>2：在QT中编译mysql驱动：<br>在QT的mysql.pro文件中<br>输入以下代码:注意用$$quote(地址)是为了忽视地址中的空格，这样在QT调用的时候就不会因为空格找不到文件。</p><pre><code>    win32:LIBS += -L$$quote(D:/mySQL/MySQL Server 8.0/lib) -llibmysql    INCLUDEPATH += $$quote(D:/mySQL/MySQL Server 8.0/include)    DEPENDPATH += $$quote(D:/mySQL/MySQL Server 8.0/include)</code></pre><p>括号中的地址填你之际的安装地址。</p><p>同时注释掉文件中</p><pre><code>    #QMAKE_USE += mysql</code></pre><p>用MINGW64编译文件，在QT同级目录下出现plugins文件夹。</p><p>3：将mysql数据库动态文件及编译文件粘贴到QT<br>将plugins文件夹生成的qsqlmysql.dll 与qsqlmysql.dll.debug复制到<br>D:\QT\set_qt\5.14.1\mingw73_64\bin</p><p>将动态库文件mysql/lib中的libmysql.dll复制到QT的MINGW64编译器的bin目录下</p><p>4：连接数据库：<br>新建文件，在.pro文件中<br>QT       += core gui sql<br>在用到数据库的.h文件中</p><h1 id="include-lt-QSqlDatabase-gt"><a href="#include-lt-QSqlDatabase-gt" class="headerlink" title="include &lt; QSqlDatabase &gt;"></a>include &lt; QSqlDatabase &gt;</h1><p>在.cpp中连接数据库：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase(<span class="string">&quot;QMYSQL&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">db.setHostName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">db.setUserName(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">db.setPassword(<span class="string">&quot;119568yhl&quot;</span>);</span><br><span class="line">db.setDatabaseName (<span class="string">&quot;info&quot;</span>);<span class="comment">// 这里 info 是实例化数据库的名称，需要手动实例化。</span></span><br><span class="line">qDebug()&lt;&lt;<span class="string">&quot;连接数据库&quot;</span>;</span><br><span class="line">QSqlQuery <span class="title function_">query</span><span class="params">(db)</span>;</span><br></pre></td></tr></table></figure><br>d是连接名，这是一个程序在不同处对不同的数据库进行操作，就应该给每个数据库定义连接名<br>如果只是有一处需要动用数据库，可以<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">db.setHostName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">db.setUserName(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">db.setPassword(<span class="string">&quot;119568yhl&quot;</span>);</span><br><span class="line">db.setDatabaseName (<span class="string">&quot;info&quot;</span>);<span class="comment">// 这里 info 是实例化数据库的名称，需要手动实例化。</span></span><br><span class="line">qDebug()&lt;&lt;<span class="string">&quot;连接数据库&quot;</span>;</span><br><span class="line">QSqlQuery query;</span><br></pre></td></tr></table></figure></p><p><img src="/img/database.png" alt="在cmd登录实并例化数据库方法"></p><p>第1步参考视频：<br><a href="https://www.bilibili.com/video/BV12q4y1477i/?spm_id_from=333.880.my_history.page.click">https://www.bilibili.com/video/BV12q4y1477i/?spm_id_from=333.880.my_history.page.click</a></p><p>第2，3步参考视频：<br><a href="https://www.bilibili.com/video/BV1Jk4y167tt/?spm_id_from=333.880.my_history.page.click&amp;vd_source=b6da26061de3320a8170666f06381a91">https://www.bilibili.com/video/BV1Jk4y167tt/?spm_id_from=333.880.my_history.page.click&amp;vd_source=b6da26061de3320a8170666f06381a91</a></p><pre><code>    show databases;</code></pre><p>看到数据库里的存储区</p><pre><code>    use info</code></pre><p>进入其中的一个存储区</p><pre><code>    show tables;</code></pre><p>可以看到区里具体的表</p><pre><code>    select * from 表名</code></pre><p>可以看到表里有啥</p><p>tips:</p><pre><code>QString sql1 = QString(&quot;create table %1(id double,x double,y double,h double,v double,t double)&quot;).arg(a);</code></pre><p>这样可以实现动态设置表名，例如如果需要把每个for循环采集到的数据做成一个表，那么就可以这样动态设置表名<br>表名必须是字母！<br>也可以用函数获取当前的绝对时间，arg(时间)，来实现动态设置表名</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针，踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编程技巧</title>
      <link href="/python/"/>
      <url>/python/</url>
      
        <content type="html"><![CDATA[<!-- timeline 2022-12-10 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><p>&emsp;&emsp;markdown语言中%可能引发歧义！报错 tag name expected<br><!-- endtimeline --></p><!-- timeline 2022-12-10 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><p>&emsp;&emsp;for num in range(begin,end) num从列表中依次取出begin到end-1的end-begin个整数。<br>如for num in range(1,8) ，num可以遍历到1，2，3，4，5，6，7<br>&emsp;&emsp;for id,x in enum(y) 将y中的元素标序号，id为序号，x为元素内容。<br>&emsp;&emsp;print(f”{}，{}”) 会将大括号里的变量转化为string打印。<br>&emsp;&emsp;lista = [20,10,50,40,30] 排序：lista.sort()改变了lista的顺序。 listb=sorted(lista) 不改变lista的顺序。默认是升序，（）加入reverse=true则为降序。<br>&emsp;&emsp;list中的元素由  ， 隔开。但该逗号不属于列表list的内容。<br>&emsp;&emsp;在写文件中，如果字符串内容为’…\n’，则写出的内容/n消失并换行，因此在读文件时应该处理每行末尾的\n，list[ ：-1]就可以不读入换行符\n<br><!-- endtimeline --></p><!-- timeline 2022-12-10 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><p>&emsp;&emsp;pyton的return可以返回三个值，return b,c,d 只要在主题函数中用三个变量来接收就行<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_return</span>()</span><br><span class="line">    b=<span class="number">1</span></span><br><span class="line">    c=<span class="number">2</span> </span><br><span class="line">    d=<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> b,c,d</span><br><span class="line"></span><br><span class="line">get_b,get_c,get_d = get_return()</span><br></pre></td></tr></table></figure><br><!-- endtimeline --></p><!-- timeline 2022-5-8 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><p><font color=red size=5 face="黑体">python系统路径设置：</font><br>&emsp;&emsp;sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(<strong>file</strong>)))) #将路径添加到系统路径中  将上级目录加入到系统中。<br><!-- endtimeline --></p><!-- timeline 2022-12-10 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><p><font color=red size=5 face="黑体">python模块导入：</font><br>&emsp;&emsp;x = import_module(‘bert_CNN’)和在文章头部Import相比有什么优点？<br>使用 import_module 函数动态导入模块相比于在文件开始处使用常规的 import 语句具有一些优点：</p><p>1灵活性：使用 import_module 函数可以在运行时动态导入模块，这使得你可以编写更加灵活的代码。例如，你可以根据某些条件或用户输入来决定要导入哪个模块，或者在某些情况下根本不导入模块。<br>2避免循环导入：如果两个或多个模块相互导入，而它们又被导入到另一个模块中，那么就可能会出现循环导入的情况，这会导致程序出现错误。使用 import_module 函数可以避免这种情况，因为它不会立即导入整个模块，而是在需要时才会加载它。<br>3节省资源：使用 import_module 函数可以节省内存和处理器资源，因为它只在需要时加载模块，而不是在程序启动时就立即导入所有模块。<br>4动态扩展：使用 import_module 函数可以让你编写更具有动态扩展性的程序。例如，如果你的程序需要加载第三方插件，那么你可以使用 import_module 函数来动态地加载插件模块，从而扩展程序的功能。<br>需要注意的是，使用 import_module 函数动态导入模块也存在一些缺点。例如，它可能会使代码变得更加复杂和难以理解，因为它增加了代码的动态性。此外，它还可能导致性能下降，因为它需要在运行时进行模块加载。因此，在使用 import_module 函数时需要权衡其优缺点，并选择适合自己的使用方式。<br><!-- endtimeline --></p><!-- timeline 2022-12-10 [2.0 -> 2.1](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) --><p>&emsp;&emsp;<br><!-- endtimeline --></p>]]></content>
      
      
      <categories>
          
          <category> 软硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的发展简史</title>
      <link href="/x86/"/>
      <url>/x86/</url>
      
        <content type="html"><![CDATA[<h1 id="GNU起源："><a href="#GNU起源：" class="headerlink" title="GNU起源："></a><font color=LightSeaGreen>GNU起源：</font></h1><p>&emsp;&emsp;Unix 系统被发明之后，大家用的很爽。但是后来开始收费和商业闭源了。一个叫 RMS 的大叔觉得很不爽，于是发起 GNU 计划，GNU是一个类Unix操作系统。GNU这个名字是“GNU’s Not Unix”的递归首字母缩写词，该项目模仿 Unix 的界面和使用方式，从头做一个开源的版本。然后他自己做了编辑器 Emacs 和编译器 GCC。<br>&emsp;&emsp;GNU 是一个计划或者叫运动。在这个旗帜下成立了 FSF，起草了 GPL 等。<br>&emsp;&emsp;接下来大家纷纷在 GNU 计划下做了很多的工作和项目，基本实现了当初的计划。包括核心的 gcc 和 glibc。但是 GNU 系统缺少操作系统内核。原定的内核叫 HURD，一直完不成。同时 BSD（一种 UNIX 发行版）陷入版权纠纷，x86 平台开发暂停。然后一个叫 Linus 的同学为了在 PC 上运行 Unix，在 Minix 的启发下，开发了 Linux。注意，Linux 只是一个系统内核，系统启动之后使用的仍然是 gcc 和 bash 等软件。Linus 在发布 Linux 的时候选择了 GPL，因此符合 GNU 的宗旨。<br>&emsp;&emsp;最后，大家突然发现，这玩意不正好是 GNU 计划缺的么。于是合在一起打包发布叫 GNU / Linux。然后大家念着念着省掉了前面部分，变成了 Linux 系统。实际上 Debian，RedHat 等 Linux 发行版中内核只占了很小一部分容量。</p><h1 id="GCC："><a href="#GCC：" class="headerlink" title="GCC："></a><font color=LightSeaGreen>GCC：</font></h1><p>Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p><p>gcc是GCC中的GUN C Compiler（C 编译器）<br>g++是GCC中的GUN C++ Compiler（C++编译器）</p><h1 id="g-gcc："><a href="#g-gcc：" class="headerlink" title="g++,gcc："></a><font color=LightSeaGreen>g++,gcc：</font></h1><p>&emsp;&emsp;就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</p><p>Step1：Call a preprocessor, like cpp.<br>Step2：Call an actual compiler, like cc or cc1.<br>Step3：Call an assembler, like as.<br>Step4：Call a linker, like ld</p><p>&emsp;&emsp;由于编译器是可以更换的，所以gcc不仅仅可以编译C文件<br>所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler</p><p>gcc和g++的主要区别</p><ol><li>对于 <em>.c 和 </em>.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</li><li>对于 <em>.c 和 </em>.cpp文件，g++则统一当做cpp文件编译</li><li>使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL</li><li>gcc在编译C文件时，可使用的预定义宏是比较少的</li><li>gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏</li></ol><h1 id="x86-x86-64："><a href="#x86-x86-64：" class="headerlink" title="x86,x86_64："></a><font color=LightSeaGreen>x86,x86_64：</font></h1><p>&emsp;&emsp;x86:x86是一种CPU指令集的架构，每个指令是32位，最先由Intel公司研发，x86_64表示同样基于x86指令集，但每个指令增加到64位，最先由AMD公司研发，我们电脑目前都是64位，也就是x86_64。同时64位可以兼容32位，有的软件比较古老，能在32位计算机上运行，那现在的64位电脑就可以运行。但64位的软件就不能在32位机上运行，因为位数不够。<br>&emsp;&emsp;Arm用的是32位精简指令集（x86是复杂指令集，都是同一个时期的东西），性能不行但优点是用Arm架构的产品耗能低，因此在嵌入式系统上如手机，大放异彩。手机不需要那么高的性能，但要求待机时间长，而计算机则相反，x86也就独霸了计算机领域。</p>]]></content>
      
      
      <categories>
          
          <category> 计网与操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x86 x86_64 GUN GCC g++ gcc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
